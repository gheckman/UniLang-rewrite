􏶞object􏶟
􏷲An electrical graph that can construct custom circuit configurations􏷱
􏷰Intended to be generic enough to be used for a variety of electrical system use cases.􏷯
􏷮Electrical_System􏷭
􏷬Trevor Hickey􏷫

􏷦"stddef.h"􏷥􏷢HASA: size_t􏷡
􏷦"stdioLib.h"􏷥􏷢HASA: BOOL􏷡
􏷦"Node.h"􏷥􏷢HASA: NodeOutputsT􏷡
􏷦"Paths.h"􏷥􏷢HASA: PathsOutputsT􏷡
􏷤"NodeType.h"􏷣􏷢USES: NodeTypeE􏷡
􏷤"stdio.h"􏷣􏷢USES: perror()􏷡

􏵺the maximum number of nodes a graph can hold􏵻
􏵾max number of electrical nodes􏵿
􏵼256􏵽




􏷘+􏷗􏷒􏶐􏷑
􏷐Initialize the 􏶐􏷏
􏶠􏶐 will be in an invalid state until initialized􏶡
􏶴
  //the graph starts with zero nodes, and nothing connected
  ptOutputs->m_tLocals.m_nNumberOfNodes = 0;
  
  //establish a common ground
  ptOutputs->m_tLocals.m_nCommonGround = AddNode(ptOutputs,"common ground",NODETYPE_GROUND,0,TRUE);
􏶳

􏷘+􏷗􏷒add node􏷑
􏷐Adds a specified node to the graph.􏷏
􏶠The user can construct a node into the graph, and receive back a unique ID to query for it later.􏶡
􏶜c􏶝􏷆char[MAX_NUMBER_OF_CHARACTERS_IN_NODE_NAME]􏷅􏷄name􏷃􏷀the name of the node being added􏶿
􏶜c􏶝􏷆NodeTypeE􏷅􏷄type􏷃􏷀the type of the node that is being added􏶿
􏶜c􏶝􏷆float􏷅􏷄resistance􏷃􏷀the resistence of the node being added􏶿
􏶜c􏶝􏷆BOOL􏷅􏷄has flow􏷃􏷀whether or not the node allows electricity to flow through it.􏶿
􏶾size_t􏶽􏶼id􏶻􏶺a unique id that represents the node just created.􏶹
􏶴
  //calculate the new node id
  size_t nId = ptOutputs->m_tLocals.m_nNumberOfNodes;
  
  //create the new node with a unique id
  NodeOutputsT tNode;
  InitializeNode(&tNode,szName,nId,eType,fResistance,bHasFlow);
  
  //add the new node and increment the total count.
  //the total count is used as an index, 
  //so this prepares the node list for the next insertion.
  //we also have a safety check to avoid out-of-bounds indexing
  if (ptOutputs->m_tLocals.m_nNumberOfNodes < MAX_NUMBER_OF_ELECTRICAL_NODES)
  {
    ptOutputs->m_tLocals.m_tNodes[ptOutputs->m_tLocals.m_nNumberOfNodes] = tNode;
    ++ptOutputs->m_tLocals.m_nNumberOfNodes;
  }
  else
  {
    perror("Too many nodes added to electrical graph");
  }
  
  return nId;
􏶳

􏷘+􏷗􏷒add wire􏷑
􏷐Connect two nodes together and allow electricity to flow both ways.􏷏
􏶠Connects two nodes together, adds a wire between them, and applies the appropriate junction points.􏶡
􏶜c􏶝􏷆size_t􏷅􏷄node x􏷃􏷀One of the nodes to attach to the other node.􏶿
􏶜c􏶝􏷆size_t􏷅􏷄node y􏷃􏷀One of the nodes to attach to the other node.􏶿
􏶜c􏶝􏷆float􏷅􏷄resistance􏷃􏷀The resistance of the wire.􏶿
􏶜c􏶝􏷆BOOL􏷅􏷄has flow􏷃􏷀Whether he wire has flow initially.􏶿
􏶾size_t􏶽􏶼id􏶻􏶺The id of the newly added node.􏶹
􏶴
  //calculate the wire and get the id
  size_t nId = AddNode(ptOutputs,"wire",NODETYPE_WIRE,fResistance,bHasFlow);
  
  //connect the wire between the two components
  ConnectWireBetweenTwoOtherNodesBidirectionally(ptOutputs,nId,nNodeX,nNodeY);
  
  //give the user a lookup key(an id) to their newly created node
  return nId;
􏶳

􏷘+􏷗􏷒add unidirectional wire􏷑
􏷐Connect two nodes together and allow electricity to only flow one way between them.􏷏
􏶠Connects two nodes together, adds a wire between them,
and applies the appropriate junction points.􏶡
􏶜c􏶝􏷆size_t􏷅􏷄node x􏷃􏷀One of the nodes to attach to the other. Electricity will flow from this node to the other.􏶿
􏶜c􏶝􏷆size_t􏷅􏷄node y􏷃􏷀One of the nodes to attach to the other. Electricity will NOT flow from this node to the other.􏶿
􏶜c􏶝􏷆float􏷅􏷄resistance􏷃􏷀The resistance of the wire.􏶿
􏶜c􏶝􏷆BOOL􏷅􏷄has flow􏷃􏷀Whether he wire has flow initially.􏶿
􏶾size_t􏶽􏶼id􏶻􏶺The id of the newly added node.􏶹
􏶴
  //calculate the wire and get the id
  size_t nId = AddNode(ptOutputs,"wire",NODETYPE_WIRE,fResistance,bHasFlow);
  
  //connect the wire between the two components
  ConnectWireBetweenTwoOtherNodesUnidirectionally(ptOutputs,nId,nNodeX,nNodeY);
  
  //give the user a lookup key(an id) to their newly created node
  return nId;
􏶳

􏷘+􏷗􏷒connect node to common ground􏷑
􏷐Specifies that the node passed in, has a direct connection to common ground.􏷏
􏶠Creates a connection between the component node passed in, and the internally managed ground node. 
Having nodes connect to common ground, is important for identifying valid paths through the circuit.􏶡
􏶜c􏶝􏷆size_t􏷅􏷄node􏷃􏷀The node that will be applied to ground.􏶿
􏶴
  //add a connection the the ground node which is a part of the graph itself.
  AddWire(ptOutputs,nNode,ptOutputs->m_tLocals.m_nCommonGround,0,TRUE);
􏶳

􏷘+􏷗􏷒clear voltage and current􏷑
􏷐Clears all of the calculations performed on the nodes.  Setting the voltage and current of every node to zero􏷏
􏶠Changes will often occur on the graph(new power sources started, fuses blown, etc)
This will clear all the previous calculated electrical data.􏶡
􏶴 
  //iterate over all of the node elements,
  //and clear their calculated electrical data.
  size_t nIndex = 0;
  for (; nIndex < ptOutputs->m_tLocals.m_nNumberOfNodes; ++nIndex)
  {
    ptOutputs->m_tLocals.m_tNodes[nIndex].m_fVoltage = 0;
    ptOutputs->m_tLocals.m_tNodes[nIndex].m_fResistance = 0;
  }
􏶳

􏷘+􏷗􏷒give all nodes the ability to flow􏷑
􏷐Allows flow across all nodes􏷏
􏶠Used in the event that you want all portions of the circuit to allow electrical flow􏶡
􏶴
  //iterate over all of the node elements,
  //and turn on their ability to receive flow.
  size_t nIndex = 0;
  for (; nIndex < ptOutputs->m_tLocals.m_nNumberOfNodes; ++nIndex)
  {
    ptOutputs->m_tLocals.m_tNodes[nIndex].m_bHasFlow = TRUE;
  }
􏶳

􏷘+􏷗􏷒get circuit component􏷑
􏷐Query the graph with a node id to get back the actual node.􏷏
􏶠Node ids are given to the client when they tell the graph to create nodes for them.􏶡
􏶜c􏶝􏷆size_t􏷅􏷄node􏷃􏷀The node id associated with the actual node in the graph􏶿
􏶾NodeOutputsT*􏶽􏶼circuit component􏶻􏶺the id of the newly added node􏶹
􏶴
    //query the entire list of nodes to get the one that matches the id passed in
    return &ptOutputs->m_tLocals.m_tNodes[nNode];
􏶳

􏷘+􏷗􏷒get paths to ground􏷑
􏷐Given a starting node, the function computes a matrix of all possible paths to ground.􏷏
􏶠The matrix or 'Path List' can be used later to compute electrical data. 
Elements of the matrix can be used to query the graph for the actual nodes.
see: GetCircuitComponent(size_t nNode);
􏶡
􏶜c􏶝􏷆size_t􏷅􏷄start node􏷃􏷀The starting node in which to start the traversal from.􏶿
􏶾PathsOutputsT􏶽􏶼paths to ground􏶻􏶺All of the valid electrical paths from starting node to common ground.􏶹
􏶴 
  //create a pathlist to store all of the paths
  //a path to slowly build up as we traverse,
  //and a list of already seen nodes(to avoid cycles)
  PathsOutputsT tPathList;
  PathOutputsT tList, tSeen;
  InitializePaths(&tPathList);
  InitializePath(&tList);
  InitializePath(&tSeen);
  RecursiveGatherOfPaths(ptOutputs,nStartNode,&tSeen,&tList,&tPathList);
  return tPathList;
􏶳

􏷘-􏷗􏷒connect wire between two other nodes bidirectionally􏷑
􏷐Allow current to flow bidirectionally between a wire and two nodes.􏷏
􏶠The order of NodeX and NodeY IS NOT important.􏶡
􏶜c􏶝􏷆size_t􏷅􏷄wire id􏷃􏷀the wire used in the connection process􏶿
􏶜c􏶝􏷆size_t􏷅􏷄node x􏷃􏷀one of the nodes used in the connection process􏶿
􏶜c􏶝􏷆size_t􏷅􏷄node y􏷃􏷀one of the nodes used in the connection process􏶿
􏶴
  //create a wire between two nodes that flows both ways
  AllowCurrentFlowOutOfWireToNodes(ptOutputs,nWireId,nNodeX,nNodeY);
  AllowCurrentFlowOfNodesToWireBidirectionally(ptOutputs,nWireId,nNodeX,nNodeY);
􏶳

􏷘-􏷗􏷒connect wire between two other nodes unidirectionally􏷑
􏷐Allow current to flow unidirectionally between a wire and two nodes.􏷏
􏶠The order of NodeX and NodeY IS important.􏶡
􏶜c􏶝􏷆size_t􏷅􏷄wire id􏷃􏷀The wire used in the connection process.􏶿
􏶜c􏶝􏷆size_t􏷅􏷄node x􏷃􏷀The node that will allow electricity in but not out.􏶿
􏶜c􏶝􏷆size_t􏷅􏷄node y􏷃􏷀The node that will allow electricity to flow both ways.􏶿
􏶴
  //create a wire between two nodes that flows ONE way
  AllowCurrentFlowOutOfWireToNodes(ptOutputs,nWireId,nNodeX,nNodeY);
  AllowCurrentFlowOfNodesToWireUnidirectionally(ptOutputs,nWireId,nNodeX,nNodeY);
􏶳

􏷘-􏷗􏷒allow current flow of nodes to wire bidirectionally􏷑
􏷐Part of the connection process of adding bidirectional flow between a wire and two nodes.􏷏
􏶠The order of NodeX and NodeY IS NOT important.􏶡
􏶜c􏶝􏷆size_t􏷅􏷄wire id􏷃􏷀The wire used in the connection process.􏶿
􏶜c􏶝􏷆size_t􏷅􏷄node x􏷃􏷀one of the nodes used in the connection process􏶿
􏶜c􏶝􏷆size_t􏷅􏷄node y􏷃􏷀one of the nodes used in the connection process􏶿
􏶴
  //add the bidirectional junctions for the nodes
  JunctionOutputsT tJunction;
  NodeInputsT tInputs = {0};
  InitializeJunction(&tJunction,nWireId,TRUE);
  
  //add the junction to the nodes
  tInputs.m_tJunction = tJunction;
  UpdateNode(&ptOutputs->m_tLocals.m_tNodes[nNodeX],&tInputs);
  UpdateNode(&ptOutputs->m_tLocals.m_tNodes[nNodeY],&tInputs);
􏶳

􏷘-􏷗􏷒allow current flow of nodes to wire unidirectionally􏷑
􏷐Part of the connection process of adding unidirectional flow between a wire and two nodes.􏷏
􏶠The order of NodeX and NodeY IS important.􏶡
􏶜c􏶝􏷆size_t􏷅􏷄wire id􏷃􏷀The wire used in the connection process.􏶿
􏶜c􏶝􏷆size_t􏷅􏷄node x􏷃􏷀The node that will allow electricity in but not out.􏶿
􏶜c􏶝􏷆size_t􏷅􏷄node y􏷃􏷀The node that will allow electricity to flow both ways.􏶿
􏶴
  //add the unidirectional junctions for the nodes
  JunctionOutputsT tJunctionX, tJunctionY;
  NodeInputsT tInputs = {0};
  InitializeJunction(&tJunctionX,nWireId,TRUE);
  InitializeJunction(&tJunctionY,nWireId,FALSE);
  
  //add the junctions to the nodes
  tInputs.m_tJunction = tJunctionX;
  UpdateNode(&ptOutputs->m_tLocals.m_tNodes[nNodeX],&tInputs);
  tInputs.m_tJunction = tJunctionY;
  UpdateNode(&ptOutputs->m_tLocals.m_tNodes[nNodeY],&tInputs);
􏶳

􏷘-􏷗􏷒allow current flow out of wire to nodes􏷑
􏷐Applies flow properties to wires􏷏
􏶠The graph assumes that wires themselves will always carry current both ways
The order of NodeX and NodeY IS NOT important.􏶡
􏶜c􏶝􏷆size_t􏷅􏷄wire id􏷃􏷀The wire used in the connection process.􏶿
􏶜c􏶝􏷆size_t􏷅􏷄node x􏷃􏷀one of the nodes used in the connection process􏶿
􏶜c􏶝􏷆size_t􏷅􏷄node y􏷃􏷀one of the nodes used in the connection process􏶿
􏶴
  //add the bidirectional junctions for the nodes
  JunctionOutputsT tJunctionX, tJunctionY;
  NodeInputsT tInputs = {0};
  InitializeJunction(&tJunctionX,nNodeX,TRUE);
  InitializeJunction(&tJunctionY,nNodeY,TRUE);
  
  //add the junctions to the nodes
  tInputs.m_tJunction = tJunctionX;
  UpdateNode(&ptOutputs->m_tLocals.m_tNodes[nWireId],&tInputs);
  tInputs.m_tJunction = tJunctionY;
  UpdateNode(&ptOutputs->m_tLocals.m_tNodes[nWireId],&tInputs);
􏶳

􏷘-􏷗􏷒recursive gather of paths􏷑
􏷐Recursively builds up lists of complete paths to ground while exploring all depth first paths.􏷏
􏶠Complete paths to ground represent paths that electricity is guaranteed to flow through.􏶡
􏶜c􏶝􏷆size_t􏷅􏷄node􏷃􏷀The node that the traversal is currently on.􏶿
􏶜􏶝􏷆PathOutputsT *const􏷅􏷄seen􏷃􏷀A list of nodes that have already been seen(used to avoid cycles)􏶿
􏶜􏶝􏷆PathOutputsT *const􏷅􏷄list􏷃􏷀The current list of the current depth traversal.􏶿
􏶜􏶝􏷆PathsOutputsT *const􏷅􏷄path list􏷃􏷀A list of paths to ground. This function may or may not add additional paths to the list.􏶿
􏶴

  //used for input parameters to API methods
  PathInputsT tPathInputs = {0};
  PathsInputsT tPathsInputs = {0};
  
  //check if node already exists in path
  BOOL bAlreadyExistsInPath;
  tPathInputs.m_bExists = TRUE;
  tPathInputs.m_nNode = nNode;
  UpdatePath(ptSeen,&tPathInputs);
  bAlreadyExistsInPath = ptSeen->m_bExists;
  tPathInputs.m_bExists = FALSE;
  
  
  if (!bAlreadyExistsInPath && CanBeTraveledThrough(ptOutputs,nNode))
  {
    //add the node to the list, and mark it as seen
    tPathInputs.m_bAdd = TRUE;
    UpdatePath(ptSeen,&tPathInputs);
    UpdatePath(ptList,&tPathInputs);
    
    //continue traversing if the node is not the common ground
    if (ptOutputs->m_tLocals.m_tNodes[nNode].m_eType != NODETYPE_GROUND)
    {
      TraverseNeighbors(ptOutputs,nNode,ptSeen,ptList,ptPathList);
    }
    
    //if the node is a common ground, we can assume that we've made a successful route through the circuit.
    //since this a sucessful route, we will add it to the total list of paths that we are collecting.
    else
    {
      //add the path to the list of paths
      tPathsInputs.m_tPath = *ptList;
      UpdatePaths(ptPathList,&tPathsInputs);
    }

    --ptSeen->m_nSize;
    --ptList->m_nSize;
  }
􏶳

􏷘-􏷗􏷒traverse neighbors􏷑
􏷐Gathers all of the appropriate neighbors and traverses them.􏷏
􏶠Avoids neighbors that would cause cycles.􏶡
􏶜c􏶝􏷆size_t􏷅􏷄node􏷃􏷀The node that the traversal is currently on.􏶿
􏶜􏶝􏷆PathOutputsT *const􏷅􏷄seen􏷃􏷀A list of nodes that have already been seen(used to avoid cycles)􏶿
􏶜􏶝􏷆PathOutputsT *const􏷅􏷄list􏷃􏷀The current list of the current depth traversal.􏶿
􏶜􏶝􏷆PathsOutputsT *const􏷅􏷄path list􏷃􏷀A list of paths to ground. This function may or may not add additional paths to the list.􏶿
􏶴
  //recurse down all of the neighbors that we haven't seen before,
  //and that we have the ability to flow through
  PathOutputsT tUnseenNeighbors = GetUnseenNeighbors(ptOutputs,nNode,ptSeen);
  size_t nIndex = 0;
  
  for (;nIndex < tUnseenNeighbors.m_nSize; ++nIndex)
  {
    RecursiveGatherOfPaths(ptOutputs,tUnseenNeighbors.m_nPath[nIndex],ptSeen,ptList,ptPathList);
  }
  
􏶳

􏷘-􏷗􏷒get unseen neighbors􏷑
􏷐Gets a list of a node's neighbors that have not yet been visited.􏷏
􏶠Used to avoid cycles while traversing.􏶡
􏶜c􏶝􏷆size_t􏷅􏷄node􏷃􏷀The node that whose unseen neighbors are being gathered.􏶿
􏶜􏶝􏷆PathOutputsT *const􏷅􏷄seen􏷃􏷀a list of nodes that have already been seen(unseen to filter out unseen neighbors)􏶿
􏶾PathOutputsT􏶽􏶼unseen neighbors􏶻􏶺True if current can flow through the given node of the given graph; false if it cannot.􏶹
􏶴

  //the list of unseen paths that will be built and returned
  PathOutputsT tUnseenNodes;
  size_t nIndex = 0;
  
  //used to call Add/Exists on path
  PathInputsT tPathInputs = {0};
  
  //create a list of unseen neighbors that we will build up as we discover them
  InitializePath(&tUnseenNodes);
  
  //loop over all of the junctions for a particular node
  for (;nIndex < ptOutputs->m_tLocals.m_tNodes[nNode].m_nNumberOfJunctions; ++nIndex)
  {
    
    //check if node already exists in path
    tPathInputs.m_bExists = TRUE;
    tPathInputs.m_nNode = ptOutputs->m_tLocals.m_tNodes[nNode].m_tJunctions[nIndex].m_nConnectionId;
    UpdatePath(ptSeen,&tPathInputs);
    
    //if we haven't seen the node before
    if (!ptSeen->m_bExists)
    {
      //and if the junction allows flow
      if(ptOutputs->m_tLocals.m_tNodes[nNode].m_tJunctions[nIndex].m_bHasFlow)
      {
        //add the node as it can be flowed through, and has not been visited yet
        tPathInputs.m_bExists = FALSE;
        tPathInputs.m_bAdd = TRUE;
        tPathInputs.m_nNode = ptOutputs->m_tLocals.m_tNodes[nNode].m_tJunctions[nIndex].m_nConnectionId;
        UpdatePath(&tUnseenNodes,&tPathInputs);
        tPathInputs.m_bAdd = FALSE;
      }
    }
    
  }
  
  return tUnseenNodes;
􏶳

􏷘-􏷗􏷒can be traveled through􏷑
􏷐Evaluates whether a node can be traversed through or not.􏷏
􏶠Used to avoid gathering nodes that would lead to cycles.􏶡
􏶜c􏶝􏷆size_t􏷅􏷄node􏷃􏷀The node being checked to see if current can flow through it.􏶿
􏶾BOOL􏶽􏶼can be travelled through􏶻􏶺True if current can flow through the given node of the given graph; false if it cannot.􏶹
􏶴
  //check if a component has flow using a node id
  return GetCircuitComponent(ptOutputs,nNode)->m_bHasFlow;
􏶳

􏶨An electrical graph will always have a common ground to represent complete circuit paths.􏶧
􏶦Common ground is included inside the graph as a convenience.  
It saves the user from having to create the node themselves.􏶥
􏶘-􏶙􏶮size_t􏶭􏶬common ground􏶫􏶪0􏶩

􏶨All of the nodes that make up the graph.􏶧
􏶦The entire electrical graph is represented as an array of nodes.􏶥
􏶘-􏶙􏶮NodeOutputsT[MAX_NUMBER_OF_ELECTRICAL_NODES]􏶭􏶬nodes􏶫􏶪0􏶩

􏶨The number of nodes currently inserted into the electrical graph.􏶧
􏶦This variable will increment as insertions take place.  
It is used internally to traverse the graph, and derive ids for the nodes that are returned back to the client.􏶥
􏶘-􏶙􏶮size_t􏶭􏶬number of nodes􏶫􏶪0􏶩

