􏶞object􏶟
􏷲The entire UH72A DC power system.􏷱
􏷰Contains both the DC power system circuit represented through a generic electrical graph,
as well as a collection of node IDs to target any node on the graph directly.􏷯
􏷮Electrical_System􏷭 􏷮Circuit_Box􏷭
􏷬Trevor Hickey􏷫

􏷦stddef􏷥􏷢HASA: size_t􏷡
􏷦ElectricalGraph􏷥􏷢USES: ElectricalGraphOutputsT􏷡
􏷦AfterJunctionBox􏷥 􏷢HASA: AfterJunctionBoxOutputsT􏷡
􏷦BatteryBox􏷥       􏷢HASA: BatteryBoxOutputsT􏷡
􏷦DiodeBox􏷥         􏷢HASA: DiodeBoxOutputsT􏷡
􏷦DistributionBox􏷥  􏷢HASA: DistributionBoxOutputsT􏷡
􏷦OverheadPanel􏷥  􏷢HASA: OverheadPanelOutputsT􏷡
􏷤string􏷣􏷢USES: strcpy()􏷡
􏷤AircraftGeneralConst􏷣􏷢USES: ElectricalSystemSideE􏷡

􏷘+􏷗􏷒􏶐􏷑
􏷐Initialize the 􏶐􏷏
􏶠􏶐 will be in an invalid state until initialized.
Initializing a 􏶐 will construct the entire graph, and provide valid ideas to query any node on the graph
Internally, it uses a generic electrical graph data structure to build a specific graph for the UH72A.
Portions of the graph are grouped as boxes (as seen in the DC System - Block Diagram)
The DC System block diagram can be found on page 343 of the UH-72A Training Manual)
All of the boxes contain electrical component ids 
which can be used to query the graph and get back the actual node.
􏶡
􏶴

  size_t unIndex = FIRST_ELECTRICAL_SYSTEM_SIDE;

  􏶲Create an empty generic electrical graph􏶱
  InitializeElectricalGraph(&􏵴graph􏵵);
  
  􏶲add the battery box portion to the electrical graph data structure,
  Initializing will establish all of the component IDs in the battery box􏶱
  InitializeBatteryBox(&􏵴battery box􏵵,&􏵴graph􏵵);
  
  􏶲symmetric boxes􏶱
  for (; unIndex < NUM_ELECTRICAL_SYSTEM_SIDES; ++unIndex){
    
    􏶲add the diode box portions to the electrical graph data structure,
    Initializing will establish all of the component IDs in the diode boxes􏶱
    InitializeDiodeBox(&􏵴diode box􏵵[unIndex],&􏵴graph􏵵);
    
    􏶲add the distribution box portions to the electrical graph data structure,
    Initializing will establish all of the component IDs in the distribution boxes􏶱
    InitializeDistributionBox(&􏵴distribution box􏵵[unIndex],&􏵴graph􏵵);
    
    􏶲add the after junction box portions to the electrical graph data structure,
    Initializing will establish all of the component IDs in the after junction boxes􏶱
    InitializeAfterJunctionBox(&􏵴after junction box􏵵[unIndex],&􏵴graph􏵵);
  }
  
  􏶲add the overhead panel portion to the electrical graph data structure.
  Initializing will establish all of the component IDs in the overhead panel.􏶱
  InitializeOverheadPanel(&􏵴overhead panel􏵵,&􏵴graph􏵵);
  
  􏶲connect all of the boxes together
  i.e. apply connections that aren't visible inside any of the individual boxes􏶱
  ConnectBoxesTogether(ptOutputs);
􏶳

􏷘-􏷗􏷒connect boxes together􏷑
􏷐After all of the electrical boxes ares created,
this stage adds the remaining wires to connect components in the boxes together􏷏
􏶴
  size_t unIndex = FIRST_ELECTRICAL_SYSTEM_SIDE;
  
  􏶲a junction point used to connect boxes􏶱
  size_t nJunction;
  ElectricalGraphInputsT tInputs = {0};
  tInputs.m_bAddNode = 􏵱;
  
  􏶲add the junction to graph􏶱
  strcpy(tInputs.m_szName, "junction");
  tInputs.m_eType = NODE_TYPE_JUNCTION;
  tInputs.m_fResistance = 0;
  tInputs.m_bHasFlow = 􏵱;
  UpdateElectricalGraph(&􏵴graph􏵵,&tInputs);
  nJunction = 􏵴graph􏵵.m_unId;
  
  tInputs.m_bAddNode = 􏵰;
  tInputs.m_bAddWire = 􏵱;
  
  􏶲connect nodes from other boxes together􏶱
  
  􏶲connects battery bus to diode boxes􏶱
  tInputs.m_unNodeX = 􏵴battery box􏵵.m_unFuse1;
  tInputs.m_unNodeY = 􏵴diode box􏵵[ELECTRICAL_SYSTEM_SIDE_LEFT].m_unDiode3;
  tInputs.m_fResistance = 0;
  tInputs.m_bHasFlow = 􏵱;
  UpdateElectricalGraph(&􏵴graph􏵵,&tInputs);
  
  tInputs.m_unNodeX = 􏵴battery box􏵵.m_unFuse3;
  tInputs.m_unNodeY = 􏵴diode box􏵵[ELECTRICAL_SYSTEM_SIDE_RIGHT].m_unDiode3;
  tInputs.m_fResistance = 0;
  tInputs.m_bHasFlow = 􏵱;
  UpdateElectricalGraph(&􏵴graph􏵵,&tInputs);
  
  tInputs.m_unNodeX = nJunction;
  tInputs.m_unNodeY = 􏵴battery box􏵵.m_unFuse2;
  tInputs.m_fResistance = 0;
  tInputs.m_bHasFlow = 􏵱;
  UpdateElectricalGraph(&􏵴graph􏵵,&tInputs);
  
  
  􏶲symmetric connections􏶱
  for (; unIndex < NUM_ELECTRICAL_SYSTEM_SIDES; ++unIndex){
    
    􏶲junction connects distribution boxes and battery box􏶱
    tInputs.m_unNodeX = nJunction;
    tInputs.m_unNodeY = 􏵴distribution box􏵵[unIndex].m_unBusTieRelay;
    tInputs.m_fResistance = 0;
    tInputs.m_bHasFlow = 􏵱;
    UpdateElectricalGraph(&􏵴graph􏵵,&tInputs);
    
    tInputs.m_unNodeX = 􏵴diode box􏵵[unIndex].m_unDiode1;
    tInputs.m_unNodeY = 􏵴overhead panel􏵵.m_unEssentialBus[unIndex];
    tInputs.m_fResistance = 0;
    tInputs.m_bHasFlow = 􏵱;
    UpdateElectricalGraph(&􏵴graph􏵵,&tInputs);

    tInputs.m_unNodeX = 􏵴diode box􏵵[unIndex].m_unDiode2;
    tInputs.m_unNodeY = 􏵴overhead panel􏵵.m_unEssentialBus[unIndex];
    tInputs.m_fResistance = 0;
    tInputs.m_bHasFlow = 􏵱;
    UpdateElectricalGraph(&􏵴graph􏵵,&tInputs);

    tInputs.m_unNodeX = 􏵴diode box􏵵[unIndex].m_unDiode3;
    tInputs.m_unNodeY = 􏵴overhead panel􏵵.m_unEssentialBus[unIndex];
    tInputs.m_fResistance = 0;
    tInputs.m_bHasFlow = 􏵱;
    UpdateElectricalGraph(&􏵴graph􏵵,&tInputs);
    
    􏶲connect the overhead panel to the distribution and diode boxes􏶱
    tInputs.m_unNodeX = 􏵴distribution box􏵵[unIndex].m_unShedBusRelay;
    tInputs.m_unNodeY = 􏵴overhead panel􏵵.m_unShedBus[unIndex];
    tInputs.m_fResistance = 0;
    tInputs.m_bHasFlow = 􏵱;
    UpdateElectricalGraph(&􏵴graph􏵵,&tInputs);
    
    􏶲connects distribution boxes with after junction boxes􏶱
    tInputs.m_unNodeX = 􏵴distribution box􏵵[unIndex].m_unMainBus;
    tInputs.m_unNodeY = 􏵴after junction box􏵵[unIndex].m_unGeneratorBus;
    tInputs.m_fResistance = 0;
    tInputs.m_bHasFlow = 􏵱;
    UpdateElectricalGraph(&􏵴graph􏵵,&tInputs);
    
    􏶲connects diode boxes with distribution boxes􏶱
    tInputs.m_unNodeX = 􏵴diode box􏵵[unIndex].m_unDiode1;
    tInputs.m_unNodeY = 􏵴distribution box􏵵[unIndex].m_unFuse3;
    tInputs.m_fResistance = 0;
    tInputs.m_bHasFlow = 􏵱;
    UpdateElectricalGraph(&􏵴graph􏵵,&tInputs);
  }
  
  􏶲distribution to diode box crossover􏶱
  tInputs.m_unNodeX = 􏵴diode box􏵵[ELECTRICAL_SYSTEM_SIDE_LEFT].m_unDiode2;
  tInputs.m_unNodeY = 􏵴distribution box􏵵[ELECTRICAL_SYSTEM_SIDE_RIGHT].m_unFuse4;
  tInputs.m_fResistance = 0;
  tInputs.m_bHasFlow = 􏵱;
  UpdateElectricalGraph(&􏵴graph􏵵,&tInputs);
    
  􏶲distribution to diode box crossover􏶱
  tInputs.m_unNodeX = 􏵴diode box􏵵[ELECTRICAL_SYSTEM_SIDE_RIGHT].m_unDiode2;
  tInputs.m_unNodeY = 􏵴distribution box􏵵[ELECTRICAL_SYSTEM_SIDE_LEFT].m_unFuse4;
  tInputs.m_fResistance = 0;
  tInputs.m_bHasFlow = 􏵱;
  UpdateElectricalGraph(&􏵴graph􏵵,&tInputs);
  

􏶳

􏶨The UH72A Electrical System represented in a generic electrical graph data structure.􏶧
􏶦Using the Ids in the electrical boxes below,
individual nodes on the electrical graph may be queried directly.􏶥
􏶌observe􏶑􏶘-􏶙􏶰􏶯􏶮ElectricalGraphOutputsT􏶭􏶬graph􏶫􏶪0􏶩

􏶨An electrical box of the UH72A 􏶏􏶧
􏶦Contains node IDs that correlate to the actual nodes in the graph.􏶥
􏶌observe􏶑􏶘-􏶙􏶰􏶯􏶮BatteryBoxOutputsT􏶭􏶬battery box􏶫􏶪0􏶩

􏶨An electrical box of the UH72A 􏶏􏶧
􏶦Contains node IDs that correlate to the actual nodes in the graph.􏶥
􏶌observe􏶑􏶘-􏶙􏶰􏶯􏶮DiodeBoxOutputsT[2]􏶭􏶬diode box􏶫􏶪0􏶩

􏶨An electrical box of the UH72A 􏶏􏶧
􏶦Contains node IDs that correlate to the actual nodes in the graph.􏶥
􏶌observe􏶑􏶘-􏶙􏶰􏶯􏶮DistributionBoxOutputsT[2]􏶭􏶬distribution box􏶫􏶪0􏶩

􏶨An electrical box of the UH72A 􏶏􏶧
􏶦Contains node IDs that correlate to the actual nodes in the graph.􏶥
􏶌observe􏶑􏶘-􏶙􏶰􏶯􏶮AfterJunctionBoxOutputsT[2]􏶭􏶬after junction box􏶫􏶪0􏶩

􏶨The overhead panel of the UH72A 􏶏􏶧
􏶦Contains node IDs that correlate to the actual nodes in the graph.
The panel contains both left and right sides of symetric devices internally.􏶥
􏶌observe􏶑􏶘-􏶙􏶰􏶯􏶮OverheadPanelOutputsT􏶭􏶬overhead panel􏶫􏶪0􏶩
