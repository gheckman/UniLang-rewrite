􏶞object􏶟
􏷲A 􏶏 specific to the UH72A DC power system.􏷱
􏷰Stores a collection of 􏶏 node IDs and builds them into the generic electrical graph.􏷯
􏷮Electrical_System􏷭 􏷮Circuit_Box􏷭
􏷬Trevor Hickey􏷫

􏷦stddef􏷥􏷢HASA: size_t􏷡
􏷦ElectricalGraph􏷥􏷢USES: ElectricalGraphOutputsT􏷡
􏷤string􏷣􏷢USES: strcpy()􏷡

􏷘+􏷗􏷒􏶐􏷑
􏷐Initialize the 􏶐􏷏
􏶠􏶐 will be in an invalid state until initialized.
Initializing a 􏶐 will construct all of its nodes into the generic electrical graph.
It will store the IDs given back by the graph so that they may be queried later by the user.􏶡
􏶜􏶝􏷆ElectricalGraphOutputsT*const􏷅􏷄graph􏷃􏷀A generic electrical graph that the 􏶏 will construct its nodes into.􏶿
􏶴
  􏶲create all the internal nodes inside the graph data structure􏶱
  CreateNodes(ptOutputs,ptGraph);
  
  􏶲connect these newly created nodes􏶱
  CreateWires(ptOutputs,ptGraph);
  
  􏶲apply any nodes to ground that should be􏶱
  ApplyNodesToGround(ptOutputs,ptGraph);
􏶳

􏷘-􏷗􏷒create nodes􏷑
􏷐Constructs all of the electrical components into the generic electrical graph data structure.􏷏
􏶠This will give all of the node a valid id for querying the graph later.􏶡
􏶜􏶝􏷆ElectricalGraphOutputsT*const􏷅􏷄graph􏷃􏷀A generic electrical graph that the 􏶏 will construct its nodes into.􏶿
􏶴
  􏶲create all of the vertexes that are part of the 􏶐
  the essential bus is technically outside the 􏶐,
  but we include it here for conceptual organization􏶱
  ElectricalGraphInputsT tInputs = {0};
  tInputs.m_bAddNode = 􏵱;
  
  􏶲add node to graph􏶱
  strcpy(tInputs.m_szName, "battery");
  tInputs.m_eType = NODE_TYPE_BATTERY;
  tInputs.m_fResistance = 0;
  tInputs.m_bHasFlow = 􏵱;
  UpdateElectricalGraph(ptGraph,&tInputs);
  􏵴battery􏵵 = ptGraph->m_nId;
  
  􏶲add node to graph􏶱
  strcpy(tInputs.m_szName, "battery hot bus");
  tInputs.m_eType = NODE_TYPE_BUS;
  tInputs.m_fResistance = 0;
  tInputs.m_bHasFlow = 􏵱;
  UpdateElectricalGraph(ptGraph,&tInputs);
  􏵴hot bus􏵵 = ptGraph->m_nId;
  
  􏶲add node to graph􏶱
  strcpy(tInputs.m_szName, "battery relay");
  tInputs.m_eType = NODE_TYPE_RELAY;
  tInputs.m_fResistance = 0;
  tInputs.m_bHasFlow = 􏵰;
  UpdateElectricalGraph(ptGraph,&tInputs);
  􏵴relay􏵵 = ptGraph->m_nId;
  
  􏶲add node to graph􏶱
  strcpy(tInputs.m_szName, "battery bus");
  tInputs.m_eType = NODE_TYPE_BUS;
  tInputs.m_fResistance = 0;
  tInputs.m_bHasFlow = 􏵱;
  UpdateElectricalGraph(ptGraph,&tInputs);
  􏵴bus􏵵 = ptGraph->m_nId;
  
  􏶲add node to graph􏶱
  strcpy(tInputs.m_szName, "battery bus fuse 1");
  tInputs.m_eType = NODE_TYPE_FUSE;
  tInputs.m_fResistance = 0;
  tInputs.m_bHasFlow = 􏵱;
  UpdateElectricalGraph(ptGraph,&tInputs);
  􏵴fuse 1􏵵 = ptGraph->m_nId;
  
  􏶲add node to graph􏶱
  strcpy(tInputs.m_szName, "battery bus fuse 2");
  tInputs.m_eType = NODE_TYPE_FUSE;
  tInputs.m_fResistance = 0;
  tInputs.m_bHasFlow = 􏵱;
  UpdateElectricalGraph(ptGraph,&tInputs);
  􏵴fuse 2􏵵 = ptGraph->m_nId;
  
  􏶲add node to graph􏶱
  strcpy(tInputs.m_szName, "battery bus fuse 3");
  tInputs.m_eType = NODE_TYPE_FUSE;
  tInputs.m_fResistance = 0;
  tInputs.m_bHasFlow = 􏵱;
  UpdateElectricalGraph(ptGraph,&tInputs);
  􏵴fuse 3􏵵 = ptGraph->m_nId;
  
  􏶲add node to graph􏶱
  strcpy(tInputs.m_szName, "external power relay");
  tInputs.m_eType = NODE_TYPE_RELAY;
  tInputs.m_fResistance = 0;
  tInputs.m_bHasFlow = 􏵰;
  UpdateElectricalGraph(ptGraph,&tInputs);
  􏵴external power relay􏵵= ptGraph->m_nId;
  
  􏶲add node to graph􏶱
  strcpy(tInputs.m_szName, "external power unit");
  tInputs.m_eType = NODE_TYPE_EPU;
  tInputs.m_fResistance = 0;
  tInputs.m_bHasFlow = 􏵱;
  UpdateElectricalGraph(ptGraph,&tInputs);
  􏵴external power unit􏵵 = ptGraph->m_nId;
􏶳

􏷘-􏷗􏷒create wires􏷑
􏷐Connects all of the necessary 􏶐 nodes together.􏷏
􏶠The nodes being connected will need to be created first.􏶡
􏶜􏶝􏷆ElectricalGraphOutputsT*const􏷅􏷄graph􏷃􏷀A generic electrical graph that the 􏶏 will construct its wires into.􏶿
􏶴
  􏶲connect the related components􏶱
  ElectricalGraphInputsT tInputs = {0};
  tInputs.m_bAddWire = 􏵱;
  
  􏶲connect two nodes together􏶱
  tInputs.m_nNodeX = 􏵴battery􏵵;
  tInputs.m_nNodeY = 􏵴hot bus􏵵;
  tInputs.m_fResistance = 0;
  tInputs.m_bHasFlow = 􏵱;
  UpdateElectricalGraph(ptGraph,&tInputs);
  
  􏶲connect two nodes together􏶱
  tInputs.m_nNodeX = 􏵴hot bus􏵵;
  tInputs.m_nNodeY = 􏵴relay􏵵;
  tInputs.m_fResistance = 0;
  tInputs.m_bHasFlow = 􏵱;
  UpdateElectricalGraph(ptGraph,&tInputs);
  
  􏶲connect two nodes together􏶱
  tInputs.m_nNodeX = 􏵴relay􏵵;
  tInputs.m_nNodeY = 􏵴bus􏵵;
  tInputs.m_fResistance = 0;
  tInputs.m_bHasFlow = 􏵱;
  UpdateElectricalGraph(ptGraph,&tInputs);
  
  􏶲connect two nodes together􏶱
  tInputs.m_nNodeX = 􏵴bus􏵵;
  tInputs.m_nNodeY = 􏵴external power relay􏵵;
  tInputs.m_fResistance = 0;
  tInputs.m_bHasFlow = 􏵱;
  UpdateElectricalGraph(ptGraph,&tInputs);
  
  􏶲connect two nodes together􏶱
  tInputs.m_nNodeX = 􏵴external power relay􏵵;
  tInputs.m_nNodeY = 􏵴external power unit􏵵;
  tInputs.m_fResistance = 0;
  tInputs.m_bHasFlow = 􏵱;
  UpdateElectricalGraph(ptGraph,&tInputs);
  
  􏶲connect two nodes together􏶱
  tInputs.m_nNodeX = 􏵴bus􏵵;
  tInputs.m_nNodeY = 􏵴fuse 1􏵵;
  tInputs.m_fResistance = 0;
  tInputs.m_bHasFlow = 􏵱;
  UpdateElectricalGraph(ptGraph,&tInputs);
  
  􏶲connect two nodes together􏶱
  tInputs.m_nNodeX = 􏵴bus􏵵;
  tInputs.m_nNodeY = 􏵴fuse 2􏵵;
  tInputs.m_fResistance = 0;
  tInputs.m_bHasFlow = 􏵱;
  UpdateElectricalGraph(ptGraph,&tInputs);
  
  􏶲connect two nodes together􏶱
  tInputs.m_nNodeX = 􏵴bus􏵵;
  tInputs.m_nNodeY = 􏵴fuse 3􏵵;
  tInputs.m_fResistance = 0;
  tInputs.m_bHasFlow = 􏵱;
  UpdateElectricalGraph(ptGraph,&tInputs);
􏶳

􏷘-􏷗􏷒apply nodes to ground􏷑
􏷐Attach particular 􏶐 nodes to common ground.􏷏
􏶠The nodes being connected to ground will need to be created first.􏶡
􏶜􏶝􏷆ElectricalGraphOutputsT*const􏷅􏷄graph􏷃􏷀A generic electrical graph that the 􏶏 will use to connect its existing nodes to common ground.􏶿
􏶴
  􏶲apply any nodes to ground that should be􏶱
  ElectricalGraphInputsT tInputs = {0};
  tInputs.m_bConnectNodeToCommonGround = 􏵱;
  
  􏶲connect node to common ground􏶱
  tInputs.m_nNode = 􏵴battery􏵵;
  UpdateElectricalGraph(ptGraph,&tInputs);
  
  􏶲connect node to common ground􏶱
  tInputs.m_nNode = 􏵴hot bus􏵵;
  UpdateElectricalGraph(ptGraph,&tInputs);
  
  􏶲connect node to common ground􏶱
  tInputs.m_nNode = 􏵴bus􏵵;
  UpdateElectricalGraph(ptGraph,&tInputs);
􏶳

􏶨The ID of a node that is conceptually stored in a 􏶏􏶧
􏶦This ID will be used to query the generic electrical graph
and recieve back the actual node object.􏶥
􏶌observe􏶑􏶘-􏶙􏶰􏶯􏶮size_t􏶭􏶬battery􏶫􏶪0􏶩

􏶨The ID of a node that is conceptually stored in a 􏶏􏶧
􏶦This ID will be used to query the generic electrical graph
and recieve back the actual node object.􏶥
􏶌observe􏶑􏶘-􏶙􏶰􏶯􏶮size_t􏶭􏶬hot bus􏶫􏶪0􏶩

􏶨The ID of a node that is conceptually stored in a 􏶏􏶧
􏶦This ID will be used to query the generic electrical graph
and recieve back the actual node object.􏶥
􏶌observe􏶑􏶘-􏶙􏶰􏶯􏶮size_t􏶭􏶬relay􏶫􏶪0􏶩

􏶨The ID of a node that is conceptually stored in a 􏶏􏶧
􏶦This ID will be used to query the generic electrical graph
and recieve back the actual node object.􏶥
􏶌observe􏶑􏶘-􏶙􏶰􏶯􏶮size_t􏶭􏶬bus􏶫􏶪0􏶩

􏶨The ID of a node that is conceptually stored in a 􏶏􏶧
􏶦This ID will be used to query the generic electrical graph
and recieve back the actual node object.􏶥
􏶌observe􏶑􏶘-􏶙􏶰􏶯􏶮size_t􏶭􏶬fuse 1􏶫􏶪0􏶩

􏶨The ID of a node that is conceptually stored in a 􏶏􏶧
􏶦This ID will be used to query the generic electrical graph
and recieve back the actual node object.􏶥
􏶌observe􏶑􏶘-􏶙􏶰􏶯􏶮size_t􏶭􏶬fuse 2􏶫􏶪0􏶩

􏶨The ID of a node that is conceptually stored in a 􏶏􏶧
􏶦This ID will be used to query the generic electrical graph
and recieve back the actual node object.􏶥
􏶌observe􏶑􏶘-􏶙􏶰􏶯􏶮size_t􏶭􏶬fuse 3􏶫􏶪0􏶩

􏶨The ID of a node that is conceptually stored in a 􏶏􏶧
􏶦This ID will be used to query the generic electrical graph
and recieve back the actual node object.􏶥
􏶌observe􏶑􏶘-􏶙􏶰􏶯􏶮size_t􏶭􏶬external power relay􏶫􏶪0􏶩

􏶨The ID of a node that is conceptually stored in a 􏶏􏶧
􏶦This ID will be used to query the generic electrical graph
and recieve back the actual node object.􏶥
􏶌observe􏶑􏶘-􏶙􏶰􏶯􏶮size_t􏶭􏶬external power unit􏶫􏶪0􏶩

