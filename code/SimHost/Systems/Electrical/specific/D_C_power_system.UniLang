􏶞o􏶟
􏷲The entire UH72A DC power system.􏷱
􏷰Contains both the DC power system circuit represented through a generic electrical graph,
as well as a collection of node IDs to target any node on the graph directly.􏷯
􏷮Electrical_System􏷭 􏷮Circuit_Box􏷭
􏷬Trevor Hickey􏷫

􏷤􏷣􏷦stddef􏷥􏷢HASA: size_t􏷡
􏷤􏷣􏷦ElectricalGraph􏷥􏷢USES: ElectricalGraphOutputsT􏷡
􏷤􏷣􏷦AfterJunctionBox􏷥􏷢HASA: AfterJunctionBoxOutputsT􏷡
􏷤􏷣􏷦BatteryBox􏷥􏷢HASA: BatteryBoxOutputsT􏷡
􏷤􏷣􏷦DiodeBox􏷥􏷢HASA: DiodeBoxOutputsT􏷡
􏷤􏷣􏷦DistributionBox􏷥􏷢HASA: DistributionBoxOutputsT􏷡
􏷤􏷣􏷦OverheadPanel􏷥􏷢HASA: OverheadPanelOutputsT􏷡
􏶔􏶕􏶒string􏶓􏶖USES: strcpy()􏶗
􏶔􏶕􏶒AircraftGeneralConst􏶓􏶖USES: ElectricalSystemSideE􏶗

􏷘+􏷗􏷒􏶐􏷑
􏷐Initialize the 􏶐􏷏
􏶠􏶐 will be in an invalid state until initialized.
Initializing a 􏶐 will construct the entire graph, and provide valid ideas to query any node on the graph
Internally, it uses a generic electrical graph data structure to build a specific graph for the UH72A.
Portions of the graph are grouped as boxes (as seen in the DC System - Block Diagram)
The DC System block diagram can be found on page 343 of the UH-72A Training Manual)
All of the boxes contain electrical component ids 
which can be used to query the graph and get back the actual node.
􏶡
􏶴

  size_t uIndex = FIRST_ELECTRICAL_SYSTEM_SIDE;

  􏶲Create an empty generic electrical graph􏶱
  InitializeElectricalGraph(&􏵴graph􏵵);
  
  􏶲add the battery box portion to the electrical graph data structure,
  Initializing will establish all of the component IDs in the battery box􏶱
  InitializeBatteryBox(&􏵴battery box􏵵,&􏵴graph􏵵);
  
  􏶲symmetric boxes􏶱
  for (; uIndex < NUM_ELECTRICAL_SYSTEM_SIDES; ++uIndex){
    
    􏶲add the diode box portions to the electrical graph data structure,
    Initializing will establish all of the component IDs in the diode boxes􏶱
    InitializeDiodeBox(&􏵴diode box􏵵[uIndex],&􏵴graph􏵵);
    
    􏶲add the distribution box portions to the electrical graph data structure,
    Initializing will establish all of the component IDs in the distribution boxes􏶱
    InitializeDistributionBox(&􏵴distribution box􏵵[uIndex],&􏵴graph􏵵);
    
    􏶲add the after junction box portions to the electrical graph data structure,
    Initializing will establish all of the component IDs in the after junction boxes􏶱
    InitializeAfterJunctionBox(&􏵴after junction box􏵵[uIndex],&􏵴graph􏵵);
  }
  
  􏶲add the overhead panel portion to the electrical graph data structure.
  Initializing will establish all of the component IDs in the overhead panel.􏶱
  InitializeOverheadPanel(&􏵴overhead panel􏵵,&􏵴graph􏵵);
  
  􏶲connect all of the boxes together
  i.e. apply connections that aren't visible inside any of the individual boxes􏶱
  ConnectBoxesTogether(ptOutputs);
􏶳

􏷘+􏷗􏷒~􏶐􏷑
􏷐Destruct the 􏶐􏷏
􏶠􏶐 will leak memory unless destructed􏶡
􏶴
  􏶲C does not have destructors.􏶱
  DestructElectricalGraph(&􏵴graph􏵵);
􏶳

􏷘-􏷗􏷒connect boxes together􏷑
􏷐After all of the electrical boxes ares created,
this stage adds the remaining wires to connect components in the boxes together􏷏
􏶴
  size_t uIndex = FIRST_ELECTRICAL_SYSTEM_SIDE;
  
  􏶲a junction point used to connect boxes􏶱
  size_t nJunction;
  ElectricalGraphInputsT tInputs = {0};
  tInputs.m_bAddNode = 􏵱;
  
  􏶲add the junction to graph􏶱
  strcpy(tInputs.m_szName, "junction");
  tInputs.m_eType = NODE_TYPE_JUNCTION;
  tInputs.m_fResistance = 0.0f;
  tInputs.m_fExpectedAmperage = 0;
  tInputs.m_bHasFlow = 􏵱;
  UpdateElectricalGraph(&􏵴graph􏵵,&tInputs);
  nJunction = 􏵴graph􏵵.m_uId;
  
  tInputs.m_bAddNode = 􏵰;
  tInputs.m_bAddWire = 􏵱;
  
  􏶲connect nodes from other boxes together􏶱
  
  􏶲connects battery bus to diode boxes􏶱
  tInputs.m_uNodeX = 􏵴battery box􏵵.m_uFuse1;
  tInputs.m_uNodeY = 􏵴diode box􏵵[ELECTRICAL_SYSTEM_SIDE_LEFT].m_uDiode3;
  tInputs.m_fResistance = 0.0f;
  tInputs.m_fExpectedAmperage = 0.0f;
  tInputs.m_bHasFlow = 􏵱;
  UpdateElectricalGraph(&􏵴graph􏵵,&tInputs);
  
  tInputs.m_uNodeX = 􏵴battery box􏵵.m_uFuse3;
  tInputs.m_uNodeY = 􏵴diode box􏵵[ELECTRICAL_SYSTEM_SIDE_RIGHT].m_uDiode3;
  tInputs.m_fResistance = 0.0f;
  tInputs.m_fExpectedAmperage = 0.0f;
  tInputs.m_bHasFlow = 􏵱;
  UpdateElectricalGraph(&􏵴graph􏵵,&tInputs);
  
  tInputs.m_uNodeX = nJunction;
  tInputs.m_uNodeY = 􏵴battery box􏵵.m_uFuse2;
  tInputs.m_fResistance = 0.0f;
  tInputs.m_fExpectedAmperage = 0.0f;
  tInputs.m_bHasFlow = 􏵱;
  UpdateElectricalGraph(&􏵴graph􏵵,&tInputs);
  
  
  􏶲symmetric connections􏶱
  for (; uIndex < NUM_ELECTRICAL_SYSTEM_SIDES; ++uIndex){
    
    􏶲junction connects distribution boxes and battery box􏶱
    tInputs.m_uNodeX = nJunction;
    tInputs.m_uNodeY = 􏵴distribution box􏵵[uIndex].m_uBusTieRelay;
    tInputs.m_fResistance = 0.0f;
    tInputs.m_fExpectedAmperage = 0.0f;
    tInputs.m_bHasFlow = 􏵱;
    UpdateElectricalGraph(&􏵴graph􏵵,&tInputs);
    
    tInputs.m_uNodeX = 􏵴diode box􏵵[uIndex].m_uDiode1;
    tInputs.m_uNodeY = 􏵴overhead panel􏵵.m_puEssentialBus[uIndex];
    tInputs.m_fResistance = 0.0f;
    tInputs.m_fExpectedAmperage = 0.0f;
    tInputs.m_bHasFlow = 􏵱;
    UpdateElectricalGraph(&􏵴graph􏵵,&tInputs);

    tInputs.m_uNodeX = 􏵴diode box􏵵[uIndex].m_uDiode2;
    tInputs.m_uNodeY = 􏵴overhead panel􏵵.m_puEssentialBus[uIndex];
    tInputs.m_fResistance = 0.0f;
    tInputs.m_fExpectedAmperage = 0.0f;
    tInputs.m_bHasFlow = 􏵱;
    UpdateElectricalGraph(&􏵴graph􏵵,&tInputs);

    tInputs.m_uNodeX = 􏵴diode box􏵵[uIndex].m_uDiode3;
    tInputs.m_uNodeY = 􏵴overhead panel􏵵.m_puEssentialBus[uIndex];
    tInputs.m_fResistance = 0.0f;
    tInputs.m_fExpectedAmperage = 0.0f;
    tInputs.m_bHasFlow = 􏵱;
    UpdateElectricalGraph(&􏵴graph􏵵,&tInputs);
    
    􏶲connect the overhead panel to the distribution and diode boxes􏶱
    tInputs.m_uNodeX = 􏵴distribution box􏵵[uIndex].m_uShedBusRelay;
    tInputs.m_uNodeY = 􏵴overhead panel􏵵.m_puShedBus[uIndex];
    tInputs.m_fResistance = 0.0f;
    tInputs.m_fExpectedAmperage = 0.0f;
    tInputs.m_bHasFlow = 􏵱;
    UpdateElectricalGraph(&􏵴graph􏵵,&tInputs);
    
    􏶲connects distribution boxes with after junction boxes􏶱
    tInputs.m_uNodeX = 􏵴distribution box􏵵[uIndex].m_uMainBus;
    tInputs.m_uNodeY = 􏵴after junction box􏵵[uIndex].m_uGeneratorBus;
    tInputs.m_fResistance = 0.0f;
    tInputs.m_fExpectedAmperage = 0.0f;
    tInputs.m_bHasFlow = 􏵱;
    UpdateElectricalGraph(&􏵴graph􏵵,&tInputs);
    
    􏶲connects diode boxes with distribution boxes􏶱
    tInputs.m_uNodeX = 􏵴diode box􏵵[uIndex].m_uDiode1;
    tInputs.m_uNodeY = 􏵴distribution box􏵵[uIndex].m_uFuse3;
    tInputs.m_fResistance = 0.0f;
    tInputs.m_fExpectedAmperage = 0.0f;
    tInputs.m_bHasFlow = 􏵱;
    UpdateElectricalGraph(&􏵴graph􏵵,&tInputs);
  }
  
  􏶲distribution to diode box crossover􏶱
  tInputs.m_uNodeX = 􏵴diode box􏵵[ELECTRICAL_SYSTEM_SIDE_LEFT].m_uDiode2;
  tInputs.m_uNodeY = 􏵴distribution box􏵵[ELECTRICAL_SYSTEM_SIDE_RIGHT].m_uFuse4;
  tInputs.m_fResistance = 0.0f;
  tInputs.m_fExpectedAmperage = 0.0f;
  tInputs.m_bHasFlow = 􏵱;
  UpdateElectricalGraph(&􏵴graph􏵵,&tInputs);
    
  􏶲distribution to diode box crossover􏶱
  tInputs.m_uNodeX = 􏵴diode box􏵵[ELECTRICAL_SYSTEM_SIDE_RIGHT].m_uDiode2;
  tInputs.m_uNodeY = 􏵴distribution box􏵵[ELECTRICAL_SYSTEM_SIDE_LEFT].m_uFuse4;
  tInputs.m_fResistance = 0.0f;
  tInputs.m_fExpectedAmperage = 0.0f;
  tInputs.m_bHasFlow = 􏵱;
  UpdateElectricalGraph(&􏵴graph􏵵,&tInputs);
􏶳

􏶨The UH72A Electrical System represented in a generic electrical graph data structure.􏶧
􏶦Using the Ids in the electrical boxes below,
individual nodes on the electrical graph may be queried directly.􏶥
􏶌g􏶑􏶘-􏶙􏶰􏶯􏶮ElectricalGraphOutputsT􏶭􏶬graph􏶫􏶪0􏶩

􏶨An electrical box of the UH72A 􏶏􏶧
􏶦Contains node IDs that correlate to the actual nodes in the graph.􏶥
􏶌g􏶑􏶘-􏶙􏶰􏶯􏶮BatteryBoxOutputsT􏶭􏶬battery box􏶫􏶪0􏶩

􏶨An electrical box of the UH72A 􏶏􏶧
􏶦Contains node IDs that correlate to the actual nodes in the graph.􏶥
􏶌g􏶑􏶘-􏶙􏶰􏶯􏶮DiodeBoxOutputsT[2]􏶭􏶬diode box􏶫􏶪0􏶩

􏶨An electrical box of the UH72A 􏶏􏶧
􏶦Contains node IDs that correlate to the actual nodes in the graph.􏶥
􏶌g􏶑􏶘-􏶙􏶰􏶯􏶮DistributionBoxOutputsT[2]􏶭􏶬distribution box􏶫􏶪0􏶩

􏶨An electrical box of the UH72A 􏶏􏶧
􏶦Contains node IDs that correlate to the actual nodes in the graph.􏶥
􏶌g􏶑􏶘-􏶙􏶰􏶯􏶮AfterJunctionBoxOutputsT[2]􏶭􏶬after junction box􏶫􏶪0􏶩

􏶨The overhead panel of the UH72A 􏶏􏶧
􏶦Contains node IDs that correlate to the actual nodes in the graph.
The panel contains both left and right sides of symmetric devices internally.􏶥
􏶌g􏶑􏶘-􏶙􏶰􏶯􏶮OverheadPanelOutputsT􏶭􏶬overhead panel􏶫􏶪0􏶩
