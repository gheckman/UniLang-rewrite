􏶞g􏶟
􏷲J2 System Connection􏷱
􏷰Sends and receives J2 flight model messages􏷯
􏷮J2_Connection􏷭
􏷬Trevor Hickey􏷫

􏶔􏶕􏶒Defs􏶓􏶖USES: BYTE, WORD, DWORD􏶗
􏶔􏶕􏶒strLib􏶓􏶖USES: memcpy()􏶗
􏶔􏶕􏶒string􏶓􏶖USES: memcmp()􏶗
􏶔􏶕􏶒SocketManager􏶓􏶖USES: SocketReceive(), MAX_J2_MESSAGE_SIZE􏶗
􏶔􏶕􏶒SocketList􏶓􏶖USES: SOCKET_GEN_J2_DATA_SEND, SOCKET_GEN_J2_DATA_RECEIVE􏶗
􏶔􏶕􏶒TimeUtilities􏶓􏶖USES: DelayTaskNumberOfMilliseconds()􏶗
􏶔􏶕􏶒OwnShip􏶓􏶖USES: WriteJ2Data()􏶗
􏶔􏶕􏶒J2CommunicationConfig􏶓􏶖USES: J2_TASKDELAY_MS􏶗
􏶔􏶕􏶒SendToJ2Messages􏶓􏶖USES: all messages that get sent to J2􏶗
􏶔􏶕􏶒ReceiveFromJ2Messages􏶓􏶖USES: all messages that get received from J2􏶗
􏶔􏶕􏶒J2MessageTypes􏶓􏶖USES SimhostToJ2MessageTypeE, J2ToSimhostMessageTypeE􏶗
􏶔􏶕􏶒J2NetworkPacking􏶓􏶖USES: pack and unpack functions􏶗
􏶔􏶕􏶒stddef.h􏶓􏶖USES: size_t􏶗
􏶔􏶕􏶒J2ConnectionData􏶓􏶖USES: UpdateJ2HighSpeedOutputData(), UpdateJ2LowSpeedOutputData(), UpdateJ2RepositionRequestData(), UpdateJ2VersionRequestData()􏶗
􏶔􏶕􏶒SemaphoreManager􏶓􏶖USES: SemaphoreGive()􏶗
􏶔􏶕􏶒SemaphoreList􏶓􏶖USES: SEMAPHORE_SCHEDULE_IN􏶗
􏶔􏶕􏶒UdpConnectionUtilities􏶓􏶖USES: SendAndHandleUdpErrors(), ReportUdpRecieveStatus()􏶗

􏷘+􏷗􏷒J2 data receive􏷑
􏷐Used to sequence incoming J2 Data Messages.􏷏
􏶠This is an infinitely running task.􏶡
􏶾int􏶽􏶼status􏶻􏶺The return status of the task.  Not relevant as the task does not return.􏶹
􏶴
    􏶲Creates J2 data that will be filled􏶱
    J2InConnectionDataMessageT tJ2Data;
    memset(&tJ2Data, 0, sizeof(tJ2Data));

    while(1)
    {

        􏶲Read from Ownship in case we are only changing part of J2InConnectionDataT􏶱
        ReadJ2DataMessageData(&tJ2Data);
        
        􏶲listens for incoming data messages, and processes them into J2Data􏶱
        􏵲handle incoming data messages􏵳&tJ2Data);

        􏶲Write data back into Ownship􏶱
        WriteJ2DataMessageData(&tJ2Data);
    }

    return 0;
􏶳

􏷘+􏷗􏷒J2 control receive􏷑
􏷐Used to sequence incoming J2 Control Messages.􏷏
􏶠This is an infinitely running task.􏶡
􏶾int􏶽􏶼status􏶻􏶺The return status of the task.  Not relevant as the task does not return.􏶹
􏶴
    
    􏶲Creates J2 data that will be filled􏶱
    J2InConnectionControlMessageT tJ2Data;
    memset(&tJ2Data, 0, sizeof(tJ2Data));

    while(1)
    {

        􏶲Read from Ownship in case we are only changing part of J2InConnectionDataT􏶱
        ReadJ2ControlMessageData(&tJ2Data);
        
        􏶲listens for incoming control messages, and processes them into J2Data􏶱
        􏵲handle incoming control messages􏵳&tJ2Data);

        􏶲Write data back into Ownship􏶱
        WriteJ2ControlMessageData(&tJ2Data);
    }

    return 0;
􏶳

􏷘-􏷗􏷒handle incoming data messages􏷑
􏷐receives the J2 data message􏷏
􏶠gets the data message from the J2 flight model and writes into the J2 Data􏶡
􏶜􏶝􏷆J2InConnectionDataMessageT*const􏷅􏷄J2Data􏷃􏷀the J2 data we expect to be filled by the J2 flight model􏶿
􏶴

    􏶲buffer data􏶱
    BYTE pucDataBuffer[MAX_J2_MESSAGE_SIZE];
    
    􏶲Read UDP data􏶱
    int nBytesReceived = SocketReceive(SOCKET_GEN_J2_DATA_RECEIVE, (char *)pucDataBuffer, sizeof(pucDataBuffer));
    
    􏶲Error handling on UDP data.  Watchdog related􏶱
    ReportUdpReceiveStatus(nBytesReceived,"J2 Data Messages");
    
    􏶲unpack valid socket stream􏶱
    if (nBytesReceived != ERROR){
        g_bFMFirstTimeCompleted = TRUE;
        􏵲unpack received data message􏵳pucDataBuffer, nBytesReceived,􏵶J2Data􏵷);
    }
􏶳

􏷘-􏷗􏷒handle incoming control messages􏷑
􏷐receives the J2 control message􏷏
􏶠gets the control message from the J2 flight model and writes into the J2 Data􏶡
􏶜􏶝􏷆J2InConnectionControlMessageT*const􏷅􏷄J2Data􏷃􏷀the J2 data we expect to be filled by the J2 flight model􏶿
􏶴
    􏶲buffer data􏶱
    BYTE pucDataBuffer[MAX_J2_MESSAGE_SIZE];
    
    􏶲Read UDP data􏶱
    int nBytesReceived = SocketReceive(SOCKET_GEN_J2_CONTROL_RECEIVE, (char *)pucDataBuffer, sizeof(pucDataBuffer));
    
    􏶲Error handling on UDP data.  Watchdog related􏶱
    ReportUdpReceiveStatus(nBytesReceived,"J2 Control Messages");
    
    􏶲unpack valid socket stream􏶱
    if (nBytesReceived != ERROR){
        􏵲unpack received control message􏵳pucDataBuffer, nBytesReceived,􏵶J2Data􏵷);
    }
􏶳
􏷘-􏷗􏷒unpack received control message􏷑
􏷐processes the j2 data buffer received from the socket and unpacks it into the appropriate structure􏷏
􏶠assumes the data received over the socket was valid and completed successfully􏶡
􏶜􏶝􏷆BYTE*􏷅􏷄data buffer􏷃􏷀the buffer received from the socket􏶿
􏶜c􏶝􏷆int􏷅􏷄bytes received􏷃􏷀the amount of bytes received from the socket􏶿
􏶜􏶝􏷆J2InConnectionControlMessageT*const􏷅􏷄J2Data􏷃􏷀the J2 data we expect to be filled by the J2 flight model􏶿
􏶴
    􏶲process message and parse data received into the input communication data􏶱
    􏶲decide what data message was received, and receive it􏶱
    switch(pucDataBuffer[0]){
        case J2_TO_SIMHOST_MESSAGE_TYPE_REPOSITION_REPLY:
            UnpackJ2RepositionReceivedMessage(pucDataBuffer,nBytesReceived,&􏵶J2Data􏵷->m_tRepositionReply);
            break;
        case J2_TO_SIMHOST_MESSAGE_TYPE_VERSION:
            UnpackJ2VersionReceivedMessage(pucDataBuffer,nBytesReceived,&􏵶J2Data􏵷->m_tVersion);
            break;
        default:
            ;
    }
􏶳

􏷘-􏷗􏷒unpack received data message􏷑
􏷐processes the j2 data buffer received from the socket and unpacks it into the appropriate structure􏷏
􏶠assumes the data received over the socket was valid and completed successfully􏶡
􏶜􏶝􏷆BYTE*􏷅􏷄data buffer􏷃􏷀the buffer received from the socket􏶿
􏶜c􏶝􏷆int􏷅􏷄bytes received􏷃􏷀the amount of bytes received from the socket􏶿
􏶜􏶝􏷆J2InConnectionDataMessageT*const􏷅􏷄J2Data􏷃􏷀the J2 data we expect to be filled by the J2 flight model􏶿
􏶴
    􏶲process message and parse data received into the input communication data􏶱
    􏶲decide what data message was received, and receive it􏶱
    switch(􏵶data buffer􏵷[0]){
        case J2_TO_SIMHOST_MESSAGE_TYPE_HIGH_SPEED:
            UnpackJ2HighSpeedReceivedMessage(􏵶data buffer􏵷,􏵶bytes received􏵷,&􏵶J2Data􏵷->m_tHighSpeed);
            
            􏶲Release the "flight model arrived" semaphore􏶱
            SemaphoreGive(SEMAPHORE_SCHEDULE_IN); break;
        case J2_TO_SIMHOST_MESSAGE_TYPE_LOW_SPEED: UnpackJ2LowSpeedReceivedMessage(􏵶data buffer􏵷,􏵶bytes received􏵷,&􏵶J2Data􏵷->m_tLowSpeed); break;
        case J2_TO_SIMHOST_MESSAGE_TYPE_ENGINE:    UnpackJ2EngineReceivedMessage(􏵶data buffer􏵷,􏵶bytes received􏵷,&􏵶J2Data􏵷->m_tEngine);     break;
        default:;
    }
􏶳

􏷘+􏷗􏷒J2 send􏷑
􏷐Used to sequence outgoing J2 Messages.􏷏
􏶠This is an infinitely running task.􏶡
􏶾int􏶽􏶼status􏶻􏶺The return status of the task.  Not relevant as the task does not return.􏶹
􏶴

    􏶲all of the data that will be updated and sent to J2􏶱
    SendHighSpeedMessageT tHigh;
    SendLowSpeedMessageT tLow;
    SendRepositionMessageT tReposition;
    SendVersionRequestMessageT tVersion;
    
    
    􏶲for keeping track of change in time􏶱
    float fDeltaTime_ms = 0.0f;
    float fPreviousTime_ms = 0.0f;
    TimeSystemOutputsT tSimTimer;
    
    􏶲for handling individual transmission rates􏶱
    float fHighTimer_ms = 0;
    float fLowTimer_ms = 0;
    
    􏶲we want to set all the padding to zero.􏶱
    􏶲this way, we can compare two structs of the same type with memcmp later􏶱
    memset(&tHigh,0,sizeof(tHigh));
    memset(&tLow,0,sizeof(tLow));
    memset(&tReposition,0,sizeof(tReposition));
    memset(&tVersion,0,sizeof(tVersion));
    
    􏶲wait a second􏶱
    DelayTaskNumberOfMilliseconds(1000);
    
    while(1)
    {
    
        􏶲add delta times􏶱
        ReadTimeSystemOutput(&tSimTimer);
        fDeltaTime_ms = ((float)tSimTimer.m_dElapsedSimulatorTime_ms - fPreviousTime_ms);
        fPreviousTime_ms = (float)tSimTimer.m_dElapsedSimulatorTime_ms;
        
        􏶲increment time gone by on transmit timers􏶱
        fHighTimer_ms += fDeltaTime_ms;
        fLowTimer_ms += fDeltaTime_ms;
        
        􏶲if too much time has passed􏶱
        if (fHighTimer_ms > SIMHOST_HIGH_SPEED_TRANSMISSION_DELAY_MS){
        
            􏶲keep extra time􏶱
            fHighTimer_ms -= SIMHOST_HIGH_SPEED_TRANSMISSION_DELAY_MS;
            
            􏶲update high speed outputs􏶱
           UpdateJ2HighSpeedOutputData(&tHigh);
            
            􏶲send high speed message􏶱
            􏵲send high speed message􏵳&tHigh);
        }
        
        􏶲if too much time has passed􏶱
        if (fLowTimer_ms > SIMHOST_LOW_SPEED_TRANSMISSION_DELAY_MS){
        
            􏶲keep extra time􏶱
            fLowTimer_ms -= SIMHOST_LOW_SPEED_TRANSMISSION_DELAY_MS;
            
            􏶲update low speed outputs􏶱
           UpdateJ2LowSpeedOutputData(&tLow);
            
            􏶲send low speed message􏶱
            􏵲send low speed message􏵳&tLow);
        }
        
        􏶲conditional sending based on changed data􏶱
        􏵲send reposition message on change􏵳&tReposition);
        􏵲send version message on change􏵳&tVersion);

        􏶲delay the task􏶱
        DelayTaskNumberOfMilliseconds(J2_TASK_DELAY_MS);
    }

    return 0;
􏶳


􏷘-􏷗􏷒send reposition message on change􏷑
􏷐sends a reposition message if the structure has changed since the last time it was sent􏷏
􏶠sourcing the new data happens internally when checking for change􏶡
􏶜􏶝􏷆SendRepositionMessageT*const􏷅􏷄message􏷃􏷀the current state of the reposition data􏶿
􏶴
    􏶲if reposition has changed􏶱
    if (􏵲reposition has changed􏵳􏵶message􏵷)){

        􏶲send reposition message􏶱
        􏵲send reposition message􏵳􏵶message􏵷);
        
    }
􏶳

􏷘-􏷗􏷒send version message on change􏷑
􏷐sends a reposition message if the structure has changed since the last time it was sent􏷏
􏶠sourcing the new data happens internally when checking for change􏶡
􏶜􏶝􏷆SendVersionRequestMessageT*const􏷅􏷄message􏷃􏷀the current state of the version data􏶿
􏶴
    􏶲if version has changed􏶱
    if (􏵲version has changed􏵳􏵶message􏵷)){

        􏶲send version message􏶱
        􏵲send version message􏵳􏵶message􏵷);
        
    }
􏶳

􏷘-􏷗􏷒reposition has changed􏷑
􏷐update the reposition message, and decide if it changed􏷏
􏶠equality is checked with memcmp, so its important that both structs were memset to zero􏶡
􏶜􏶝􏷆SendRepositionMessageT*const􏷅􏷄message􏷃􏷀the message we are checking for changes in.􏶿
􏶾BOOL􏶽􏶼changed􏶻􏶺whether the message has changed or not􏶹
􏵦􏵧􏵤the message will be updated as an out parameter while comparing its equality to the previous state􏵥
􏶴
    SendRepositionMessageT tNewMessage;
    BOOL bHasChanged = FALSE;
    
    􏶲we want to set all the padding to zero.􏶱
    􏶲this way, we can compare two structs of the same type with memcmp later􏶱
    memset(&tNewMessage,0,sizeof(tNewMessage));
    
    􏶲source new message􏶱
    UpdateJ2RepositionRequestData(&tNewMessage);
    
    􏶲determine if the message has changed􏶱
    bHasChanged = memcmp(􏵶message􏵷,&tNewMessage,sizeof(tNewMessage));
    
    􏶲update the message􏶱
    *􏵶message􏵷 = tNewMessage;
    
    return bHasChanged;
􏶳

􏷘-􏷗􏷒version has changed􏷑
􏷐update the version message, and decide if it changed􏷏
􏶠equality is checked with memcmp, so its important that both structs were memset to zero􏶡
􏶜􏶝􏷆SendVersionRequestMessageT*const􏷅􏷄message􏷃􏷀the message we are checking for changes in.􏶿
􏶾BOOL􏶽􏶼changed􏶻􏶺whether the message has changed or not􏶹
􏵦􏵧􏵤the message will be updated as an out parameter while comparing its equality to the previous state􏵥
􏶴
    SendVersionRequestMessageT tNewMessage;
    BOOL bHasChanged = FALSE;
    
    􏶲we want to set all the padding to zero.􏶱
    􏶲this way, we can compare two structs of the same type with memcmp later􏶱
    memset(&tNewMessage,0,sizeof(tNewMessage));
    
    􏶲source new message􏶱
    UpdateJ2VersionRequestData(&tNewMessage);
    
    􏶲determine if the message has changed􏶱
    bHasChanged = memcmp(􏵶message􏵷,&tNewMessage,sizeof(tNewMessage));
    
    􏶲update the message􏶱
    *􏵶message􏵷 = tNewMessage;
    
    return bHasChanged;
􏶳

􏷘-􏷗􏷒send high speed message􏷑
􏷐sends the data message to J2 flight model􏷏
􏶠Uses a timer internally to only send the message when appropriate􏶡
􏶜􏶝􏷆SendHighSpeedMessageT *const􏷅􏷄message􏷃􏷀the message to send􏶿
􏶴
    􏶲initializes data buffer information􏶱
    BYTE pucDataBuffer[MAX_J2_MESSAGE_SIZE];
    size_t uByteCount=0;
    memset(pucDataBuffer, 0, MAX_J2_MESSAGE_SIZE);
    
    􏶲fill the data buffer􏶱
    uByteCount = PackJ2HighSpeedSendMessage(pucDataBuffer,􏵶message􏵷);
    
    􏶲call socket send, and handle any errors that occur􏶱
    SendAndHandleUdpErrors(uByteCount,pucDataBuffer,SOCKET_GEN_J2_DATA_SEND,"J2 High Speed Message");

􏶳
􏷘-􏷗􏷒send low speed message􏷑
􏷐sends the data message to J2 flight model􏷏
􏶠Uses a timer internally to only send the message when appropriate􏶡
􏶜􏶝􏷆SendLowSpeedMessageT *const􏷅􏷄message􏷃􏷀the message to send􏶿
􏶴
    􏶲initializes data buffer information􏶱
    BYTE pucDataBuffer[MAX_J2_MESSAGE_SIZE];
    size_t uByteCount=0;
    memset(pucDataBuffer, 0, MAX_J2_MESSAGE_SIZE);
    
    􏶲fill the data buffer􏶱
    uByteCount = PackJ2LowSpeedSendMessage(pucDataBuffer,􏵶message􏵷);
    
    􏶲call socket send, and handle any errors that occur􏶱
    SendAndHandleUdpErrors(uByteCount,pucDataBuffer,SOCKET_GEN_J2_DATA_SEND,"J2 Low Speed Message");
􏶳

􏷘-􏷗􏷒send reposition message􏷑
􏷐sends the data message to J2 flight model􏷏
􏶠Uses a timer internally to only send the message when appropriate􏶡
􏶜c􏶝􏷆SendRepositionMessageT *const􏷅􏷄message􏷃􏷀the message to send􏶿
􏶴
    􏶲initializes data buffer information􏶱
    BYTE pucDataBuffer[MAX_J2_MESSAGE_SIZE];
    size_t uByteCount=0;
    memset(pucDataBuffer, 0, MAX_J2_MESSAGE_SIZE);
    
    􏶲fill the data buffer􏶱
    uByteCount = PackJ2RepositionSendMessage(pucDataBuffer,􏵶message􏵷);
    
    􏶲call socket send, and handle any errors that occur􏶱
    SendAndHandleUdpErrors(uByteCount,pucDataBuffer,SOCKET_GEN_J2_CONTROL_SEND,"J2 Reposition Message");
􏶳

􏷘-􏷗􏷒send version message􏷑
􏷐sends the data message to J2 flight model􏷏
􏶠Uses a timer internally to only send the message when appropriate􏶡
􏶜c􏶝􏷆SendVersionRequestMessageT *const􏷅􏷄message􏷃􏷀the message to send􏶿
􏶴
    􏶲initializes data buffer information􏶱
    BYTE pucDataBuffer[MAX_J2_MESSAGE_SIZE];
    size_t uByteCount=0;
    memset(pucDataBuffer, 0, MAX_J2_MESSAGE_SIZE);
    
    􏶲fill the data buffer􏶱
    uByteCount = PackJ2VersionRequestMessage(pucDataBuffer,􏵶message􏵷);
    
    􏶲call socket send, and handle any errors that occur􏶱
    SendAndHandleUdpErrors(uByteCount,pucDataBuffer,SOCKET_GEN_J2_CONTROL_SEND,"Version Message");
􏶳
