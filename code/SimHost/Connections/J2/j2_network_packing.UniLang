􏶞g􏶟
􏷲packs and unpacks the relevant J2 messages􏷱
􏷰Based off version 2.0 of the ICD.
It would have been nice to automate the network packing/unpacking.
Or use compiler pragmas to stop padding, and make grabbing of struct chunks possible.
+----------------+----------------+----------------+----------------+
|        0       |       1-2      |        3       |     4-4095     |
+----------------+----------------+----------------+----------------+
|  Message Type  |   Byte Count   |  Message Ver.  |     Payload    |
+----------------+----------------+----------------+----------------+

 - Message Packs (callable)
 - Message Unpacks (callable)
 - Payload Packs (hidden)
 - Payload Unpacks (hidden)
 - Message Header Related
􏷯
􏷮J2_Connection􏷭􏷮Network􏷭
􏷬Trevor Hickey􏷫

􏷤􏷣􏷦J2MessageTypes.h􏷥􏷢USES: SimhostToJ2MessageTypeE􏷡
􏷤􏷣􏷦SendToJ2Messages.h􏷥􏷢USES: SendHighSpeedMessageT, SendLowSpeedMessageT, SendRepositionMessageT􏷡
􏷤􏷣􏷦ReceiveFromJ2Messages.h􏷥􏷢USES: RcvHighSpeedMessageT, RcvLowSpeedMessageT, RcvEngineDataMessageT, RepositionMessageReplyT, VersionMessageReplyT􏷡
􏷤􏷣􏷦stddef.h􏷥􏷢USES: size_t􏷡
􏷤􏷣􏷦Defs.h􏷥􏷢USES: BYTE􏷡
􏶔􏶕􏶒PackUtilities.h􏶓􏶖USES: PackBigEndian4ByteInvariance(), UnpackBigEndian4ByteInvariance􏶗
􏶔􏶕􏶒J2MessageHeader.h􏶓􏶖USES: J2MessageHeaderT􏶗
􏶔􏶕􏶒strLib.h􏶓􏶖USES: memcpy()􏶗
􏶔􏶕􏶒stdio.h􏶓􏶖USES: fprintf()􏶗

􏵺method for packing regular variables according to J2 ICD􏵻
􏵸macro uses local local buffer data implicitly􏵹
􏵐-􏵑􏵾J2_PACK_VAR(X)􏵿􏵖􏵗􏵼PackBigEndian4ByteInvariance(pucBuffer, puBufferIterator, &X, sizeof(X))􏵽

􏵺method for unpacking regular variables according to J2 ICD􏵻
􏵸macro uses local local buffer data implicitly􏵹
􏵐-􏵑􏵾J2_UNPACK_VAR(X)􏵿􏵖􏵗􏵼UnpackBigEndian4ByteInvariance(pucBuffer, puBufferIterator, &X, sizeof(X))􏵽

􏵺method for fully packing arrays according to J2 ICD􏵻
􏵸macro uses local local buffer data implicitly􏵹
􏵐-􏵑􏵾J2_Pack_Full_Array(X)􏵿􏵖􏵗􏵼PackBigEndian4ByteInvariance(pucBuffer, puBufferIterator, X, sizeof(X))􏵽

􏵺method for fully unpacking arrays according to J2 ICD􏵻
􏵸macro uses local local buffer data implicitly􏵹
􏵐-􏵑􏵾J2_UnPack_Full_Array(X)􏵿􏵖􏵗􏵼UnpackBigEndian4ByteInvariance(pucBuffer, puBufferIterator, X, sizeof(X))􏵽

􏵺method for partially packing arrays according to J2 ICD􏵻
􏵸macro uses local local buffer data implicitly􏵹
􏵐-􏵑􏵾J2_Pack_Partial_Array(X,AMOUNT,MAX)􏵿􏵖􏵗􏵼PackFirstNArrayElements(pucBuffer, puBufferIterator, X, sizeof(X[0]), AMOUNT, MAX)􏵽

􏵺method for partially packing arrays according to J2 ICD􏵻
􏵸macro uses local local buffer data implicitly􏵹
􏵐-􏵑􏵾J2_UnPack_Partial_Array(X,AMOUNT,MAX)􏵿􏵖􏵗􏵼UnpackFirstNArrayElements(pucBuffer, puBufferIterator, X, sizeof(X[0]), AMOUNT, MAX)􏵽

􏷘+􏷗􏷒pack j2 high speed send message􏷑
􏷐Used to fill buffer for sending outgoing J2 high speed message.􏷏
􏶠Called before sending out a J2 Message.􏶡
􏶜􏶝􏷆BYTE *const􏷅􏷄buffer􏷃􏷀The data buffer to pack the message in􏶿
􏶜c􏶝􏷆SendHighSpeedMessageT *const􏷅􏷄message􏷃􏷀The message to pack􏶿
􏶾size_t􏶽􏶼byte count􏶻􏶺The byte count of the filled buffer􏶹
􏶴
    size_t uByteIterator = 4;
    􏵲pack j2 high speed send message payload􏵳􏵶buffer􏵷,&uByteIterator,􏵶message􏵷);
    􏵲pack header􏵳􏵶buffer􏵷,uByteIterator,SIMHOST_TO_J2_MESSAGE_TYPE_HIGH_SPEED);
    return uByteIterator;
􏶳

􏷘+􏷗􏷒pack j2 low speed send message􏷑
􏷐Used to fill buffer for sending outgoing J2 low speed message.􏷏
􏶠Called before sending out a J2 Message.􏶡
􏶜􏶝􏷆BYTE *const􏷅􏷄buffer􏷃􏷀The data buffer to pack the message in􏶿
􏶜c􏶝􏷆SendLowSpeedMessageT *const􏷅􏷄message􏷃􏷀The message to pack􏶿
􏶾size_t􏶽􏶼byte count􏶻􏶺The byte count of the filled buffer􏶹
􏶴
    size_t uByteIterator = 4;
    􏵲pack j2 low speed send message payload􏵳􏵶buffer􏵷,&uByteIterator,􏵶message􏵷);
    􏵲pack header􏵳􏵶buffer􏵷,uByteIterator,SIMHOST_TO_J2_MESSAGE_TYPE_LOW_SPEED);
    return uByteIterator;
􏶳

􏷘+􏷗􏷒pack j2 reposition send message􏷑
􏷐Used to fill buffer for sending outgoing J2 reposition message.􏷏
􏶠Called before sending out a J2 Message.􏶡
􏶜􏶝􏷆BYTE *const􏷅􏷄buffer􏷃􏷀The data buffer to pack the message in􏶿
􏶜c􏶝􏷆SendRepositionMessageT *const􏷅􏷄message􏷃􏷀The message to pack􏶿
􏶾size_t􏶽􏶼byte count􏶻􏶺The byte count of the filled buffer􏶹
􏶴
    size_t uByteIterator = 4;
    􏵲pack j2 reposition send message payload􏵳􏵶buffer􏵷,&uByteIterator,􏵶message􏵷);
    􏵲pack header􏵳􏵶buffer􏵷,uByteIterator,SIMHOST_TO_J2_MESSAGE_TYPE_REPOSITION);
    return uByteIterator;
􏶳

􏷘+􏷗􏷒pack j2 version request message􏷑
􏷐Used to fill buffer for sending outgoing J2 version request message.􏷏
􏶠Called before sending out a J2 Message.􏶡
􏶜􏶝􏷆BYTE *const􏷅􏷄buffer􏷃􏷀The data buffer to pack the message in􏶿
􏶜c􏶝􏷆SendVersionRequestMessageT *const􏷅􏷄message􏷃􏷀The message to pack􏶿
􏶾size_t􏶽􏶼byte count􏶻􏶺The byte count of the filled buffer􏶹
􏶴
    size_t uByteIterator = 4;
    􏶲the message has no payload􏶱
    􏵲pack header􏵳􏵶buffer􏵷,uByteIterator,SIMHOST_TO_J2_MESSAGE_TYPE_VERSION);
    return uByteIterator;
􏶳





􏷘+􏷗􏷒unpack j2 high speed send message􏷑
􏷐Used to fill structure from packed incoming J2 high speed message.􏷏
􏶠Implemented in order to test the pack version􏶡
􏶜c􏶝􏷆BYTE *const􏷅􏷄buffer􏷃􏷀The data buffer to unpack the message in􏶿
􏶜c􏶝􏷆int􏷅􏷄buffer size􏷃􏷀The size of the buffer in bytes􏶿
􏶜􏶝􏷆SendHighSpeedMessageT *const􏷅􏷄message􏷃􏷀The message to unpack􏶿
􏶾size_t􏶽􏶼byte count􏶻􏶺The byte count of the filled buffer; 0 indicates an unsuccessful unpack􏶹
􏶴
    size_t uByteIterator = 4;
    J2MessageHeaderT tHeader = 􏵲unpack header􏵳􏵶buffer􏵷);
    if (􏵲message size matches header claim􏵳tHeader,􏵶buffer size􏵷)){
      􏵲unpack j2 high speed send message payload􏵳􏵶buffer􏵷,&uByteIterator,􏵶message􏵷);
      return uByteIterator;
    }
    return 0;
􏶳

􏷘+􏷗􏷒unpack j2 high speed received message􏷑
􏷐Used to unpack the incoming J2 high speed message.􏷏
􏶠Called after receiving a J2 Message.􏶡
􏶜c􏶝􏷆BYTE *const􏷅􏷄buffer􏷃􏷀The data buffer to unpack the message from􏶿
􏶜c􏶝􏷆int􏷅􏷄buffer size􏷃􏷀The size of the buffer in bytes􏶿
􏶜􏶝􏷆RcvHighSpeedMessageT *const􏷅􏷄message􏷃􏷀The message to unpack􏶿
􏶾size_t􏶽􏶼byte count􏶻􏶺The byte count of the filled buffer; 0 indicates an unsuccessful unpack􏶹
􏶴
    size_t uByteIterator = 4;
    J2MessageHeaderT tHeader = 􏵲unpack header􏵳􏵶buffer􏵷);
    if (􏵲message size matches header claim􏵳tHeader,􏵶buffer size􏵷)){
      􏵲unpack j2 high speed received message payload􏵳􏵶buffer􏵷,&uByteIterator,􏵶message􏵷);
      return uByteIterator;
    }
    return 0;
􏶳

􏷘+􏷗􏷒unpack j2 low speed received message􏷑
􏷐Used to unpack the incoming J2 low speed message.􏷏
􏶠Called after receiving a J2 Message.􏶡
􏶜c􏶝􏷆BYTE *const􏷅􏷄buffer􏷃􏷀The data buffer to unpack the message from􏶿
􏶜c􏶝􏷆int􏷅􏷄buffer size􏷃􏷀The size of the buffer in bytes􏶿
􏶜􏶝􏷆RcvLowSpeedMessageT *const􏷅􏷄message􏷃􏷀The message to unpack􏶿
􏶾size_t􏶽􏶼byte count􏶻􏶺The byte count of the filled buffer; 0 indicates an unsuccessful unpack􏶹
􏶴
    size_t uByteIterator = 4;
    J2MessageHeaderT tHeader = 􏵲unpack header􏵳􏵶buffer􏵷);
    if (􏵲message size matches header claim􏵳tHeader,􏵶buffer size􏵷)){
      􏵲unpack j2 low speed received message payload􏵳􏵶buffer􏵷,&uByteIterator,􏵶message􏵷);
      return uByteIterator;
    }
    return 0;
􏶳

􏷘+􏷗􏷒unpack j2 engine received message􏷑
􏷐Used to unpack the incoming J2 engine message.􏷏
􏶠Called after receiving a J2 Message.􏶡
􏶜c􏶝􏷆BYTE *const􏷅􏷄buffer􏷃􏷀The data buffer to unpack the message from􏶿
􏶜c􏶝􏷆int􏷅􏷄buffer size􏷃􏷀The size of the buffer in bytes􏶿
􏶜􏶝􏷆RcvEngineDataMessageT *const􏷅􏷄message􏷃􏷀The message to unpack􏶿
􏶾size_t􏶽􏶼byte count􏶻􏶺The byte count of the filled buffer; 0 indicates an unsuccessful unpack􏶹
􏶴
    size_t uByteIterator = 4;
    J2MessageHeaderT tHeader = 􏵲unpack header􏵳􏵶buffer􏵷);
    if (􏵲message size matches header claim􏵳tHeader,􏵶buffer size􏵷)){
      􏵲unpack j2 engine received message payload􏵳􏵶buffer􏵷,&uByteIterator,􏵶message􏵷);
      return uByteIterator;
    }
    return 0;
􏶳

􏷘+􏷗􏷒unpack j2 reposition received message􏷑
􏷐Used to unpack the incoming J2 reposition message.􏷏
􏶠Called after receiving a J2 Message.􏶡
􏶜c􏶝􏷆BYTE *const􏷅􏷄buffer􏷃􏷀The data buffer to unpack the message from􏶿
􏶜c􏶝􏷆int􏷅􏷄buffer size􏷃􏷀The size of the buffer in bytes􏶿
􏶜􏶝􏷆RepositionMessageReplyT *const􏷅􏷄message􏷃􏷀The message to unpack􏶿
􏶾size_t􏶽􏶼byte count􏶻􏶺The byte count of the filled buffer; 0 indicates an unsuccessful unpack􏶹
􏶴
    size_t uByteIterator = 4;
    J2MessageHeaderT tHeader = 􏵲unpack header􏵳􏵶buffer􏵷);
    if (􏵲message size matches header claim􏵳tHeader,􏵶buffer size􏵷)){
      􏵲unpack j2 reposition received message payload􏵳􏵶buffer􏵷,&uByteIterator,􏵶message􏵷);
      return uByteIterator;
    }
    return 0;
􏶳

􏷘+􏷗􏷒unpack j2 version received message􏷑
􏷐Used to unpack the incoming J2 version request message.􏷏
􏶠Called after receiving a J2 Message.􏶡
􏶜c􏶝􏷆BYTE *const􏷅􏷄buffer􏷃􏷀The data buffer to unpack the message from􏶿
􏶜c􏶝􏷆int􏷅􏷄buffer size􏷃􏷀The size of the buffer in bytes􏶿
􏶜􏶝􏷆VersionMessageReplyT *const􏷅􏷄message􏷃􏷀The message to unpack􏶿
􏶾size_t􏶽􏶼byte count􏶻􏶺The byte count of the filled buffer; 0 indicates an unsuccessful unpack􏶹
􏶴
    size_t uByteIterator = 4;
    J2MessageHeaderT tHeader = 􏵲unpack header􏵳􏵶buffer􏵷);
    if (􏵲message size matches header claim􏵳tHeader,􏵶buffer size􏵷)){
      􏵲unpack j2 version received message payload􏵳􏵶buffer􏵷,&uByteIterator,􏵶message􏵷);
      return uByteIterator;
    }
    return 0;
􏶳






􏷘-􏷗􏷒message size matches header claim􏷑
􏷐verify the message size􏷏
􏶠check that the message size in the header matches the amount of data unpacked􏶡
􏶜c􏶝􏷆J2MessageHeaderT􏷅􏷄header􏷃􏷀The unpacked header􏶿
􏶜c􏶝􏷆int􏷅􏷄buffer size􏷃􏷀The state of the iterator after an unpack􏶿
􏶾BOOL􏶽􏶼sizes match􏶻􏶺whether or not the buffer size matches the size advertised in the header􏶹
􏶴
  􏶲A sanity check to see that their header indicates the correct size of the entire message􏶱
  if (􏵶header􏵷.m_uByteCount != 􏵶buffer size􏵷){
    fprintf(stderr, "message size does not match what was indicated in the header\n");
    return 􏵰;
  }
  return 􏵱;
􏶳











􏷘-􏷗􏷒pack j2 high speed send message payload􏷑
􏷐pack the relevant data into the buffer􏷏
􏶠specific packing for high speed􏶡
􏶜􏶝􏷆BYTE *const􏷅􏷄buffer􏷃􏷀The data buffer to pack the message in􏶿
􏶜􏶝􏷆size_t*const􏷅􏷄buffer iterator􏷃􏷀the index of the buffer to start packing the data at􏶿
􏶜c􏶝􏷆SendHighSpeedMessageT *const􏷅􏷄message􏷃􏷀The message to pack􏶿
􏶴
  J2_PACK_VAR(􏵶message􏵷->m_fPitchFlightControl);
  J2_PACK_VAR(􏵶message􏵷->m_fRollFlightControl);
  J2_PACK_VAR(􏵶message􏵷->m_fYawFlightControl);
  J2_PACK_VAR(􏵶message􏵷->m_fCollectiveFlightControl);
  J2_PACK_VAR(􏵶message􏵷->m_fPitchTrimPosition);
  J2_PACK_VAR(􏵶message􏵷->m_fRollTrimPosition);
  J2_PACK_VAR(􏵶message􏵷->m_fYawTrimPosition);
  J2_PACK_FULL_ARRAY(􏵶message􏵷->m_pfYawSerialActuators);
  J2_PACK_VAR(􏵶message􏵷->m_fYawTrimActuators);
  J2_PACK_FULL_ARRAY(􏵶message􏵷->m_pfRollSerialActuators);
  J2_PACK_VAR(􏵶message􏵷->m_fRollTrimActuators);
  J2_PACK_FULL_ARRAY(􏵶message􏵷->m_pfPitchSerialActuators);
  J2_PACK_VAR(􏵶message􏵷->m_fPitchTrimActuators);
  J2_PACK_FULL_ARRAY(􏵶message􏵷->m_pfCollectiveSerialActuators);
  J2_PACK_VAR(􏵶message􏵷->m_fCollectiveTrimActuators);
  J2_PACK_VAR(􏵶message􏵷->m_nYawControlOverrideFlag);
  J2_PACK_VAR(􏵶message􏵷->m_nPitchControlOverrideFlag);
  J2_PACK_VAR(􏵶message􏵷->m_nRollControlOverrideFlag);
  J2_PACK_VAR(􏵶message􏵷->m_nCollectiveControlOverrideFlag);
  J2_PACK_VAR(􏵶message􏵷->m_fRightBrakes);
  J2_PACK_VAR(􏵶message􏵷->m_fLeftBrakes);
  J2_PACK_VAR(􏵶message􏵷->m_fNoseWheelControl);
  J2_PACK_VAR(􏵶message􏵷->m_fRotorBrake);
  J2_PACK_VAR(􏵶message􏵷->m_nWinchFlag);
  J2_PACK_VAR(􏵶message􏵷->m_fWinchLength_m);
  J2_PACK_VAR(􏵶message􏵷->m_fWinchPayloadMass_kg);
  J2_PACK_VAR(􏵶message􏵷->m_fWinchPayloadX_m);
  J2_PACK_VAR(􏵶message􏵷->m_fWinchPayloadY_m);
  J2_PACK_VAR(􏵶message􏵷->m_fWinchPayloadZ_m);
  J2_PACK_VAR(􏵶message􏵷->m_nHookFlag);
  J2_PACK_VAR(􏵶message􏵷->m_fHookLength_m);
  J2_PACK_VAR(􏵶message􏵷->m_fHookPayloadMass_Kg);
  J2_PACK_VAR(􏵶message􏵷->m_fHookPayloadX_m);
  J2_PACK_VAR(􏵶message􏵷->m_fHookPayloadY_m);
  J2_PACK_VAR(􏵶message􏵷->m_fHookPayloadZ_m);
  J2_PACK_VAR(􏵶message􏵷->m_nSASMode);
  J2_PACK_VAR(􏵶message􏵷->m_fHeightAboveTerrain_feet);
    
    􏶲contact point packing􏶱
    J2_PACK_VAR(􏵶message􏵷->m_nNumberOfContactPoints);
    J2_PACK_PARTIAL_ARRAY(􏵶message􏵷->m_pfGroundContactLocation_feet,􏵶message􏵷->m_nNumberOfContactPoints,NUM_CONTACT_LOCATION);
    
    􏶲engine related packing􏶱
    J2_PACK_VAR(􏵶message􏵷->m_nNumberOfEngines);
    J2_PACK_PARTIAL_ARRAY(􏵶message􏵷->m_pfThrottle,􏵶message􏵷->m_nNumberOfEngines,MAX_NUMBER_OF_ENGINES);
    J2_PACK_PARTIAL_ARRAY(􏵶message􏵷->m_pfMixture,􏵶message􏵷->m_nNumberOfEngines,MAX_NUMBER_OF_ENGINES);
    
    􏶲propeller packing􏶱
    J2_PACK_VAR(􏵶message􏵷->m_nNumberOfPropellers);
    J2_PACK_PARTIAL_ARRAY(􏵶message􏵷->m_pfPropPitch_degrees,􏵶message􏵷->m_nNumberOfPropellers,MAX_NUMBER_OF_PROPELLERS);
    
    􏶲fuel tank packing􏶱
    J2_PACK_VAR(􏵶message􏵷->m_nNumberOfTanks);
    J2_PACK_PARTIAL_ARRAY(􏵶message􏵷->m_pfFuelWeight_lbs,􏵶message􏵷->m_nNumberOfTanks,MAX_NUMBER_OF_FUEL_TANKS);
    
    J2_PACK_VAR(􏵶message􏵷->m_nFlag1);
􏶳

􏷘-􏷗􏷒pack j2 low speed send message payload􏷑
􏷐pack the relevant data into the buffer􏷏
􏶠specific packing for low speed􏶡
􏶜􏶝􏷆BYTE *const􏷅􏷄buffer􏷃􏷀The data buffer to pack the message in􏶿
􏶜􏶝􏷆size_t*const􏷅􏷄buffer iterator􏷃􏷀the index of the buffer to start packing the data at􏶿
􏶜c􏶝􏷆SendLowSpeedMessageT *const􏷅􏷄message􏷃􏷀The message to pack􏶿
􏶴
  􏶲gear related packing􏶱
  J2_PACK_VAR(􏵶message􏵷->m_nNumberOfGears);
  J2_PACK_PARTIAL_ARRAY(􏵶message􏵷->m_pnGearRequestedPosition_pct,􏵶message􏵷->m_nNumberOfGears,MAX_NUMBER_OF_LANDING_GEARS);
    
  􏶲flap related packing􏶱
  J2_PACK_VAR(􏵶message􏵷->m_nNumberOfFlaps);
  J2_PACK_PARTIAL_ARRAY(􏵶message􏵷->m_pnFlapRequestedPosition_pct,􏵶message􏵷->m_nNumberOfFlaps,MAX_NUMBER_OF_FLAPS);
    
  􏶲speed brake related packing􏶱
  J2_PACK_VAR(􏵶message􏵷->m_nNumberOfSpeedBrakes);
  J2_PACK_PARTIAL_ARRAY(􏵶message􏵷->m_pnSpeedBrakeRequestedPosition_pct,􏵶message􏵷->m_nNumberOfSpeedBrakes,MAX_NUMBER_OF_SPEED_BRAKES);
    
  J2_PACK_VAR(􏵶message􏵷->m_fSeaLevelPressure_inHg);
  J2_PACK_VAR(􏵶message􏵷->m_fSeaLevelTemperature_degf);
  J2_PACK_VAR(􏵶message􏵷->m_fRunwayRoughness);
  J2_PACK_VAR(􏵶message􏵷->m_fWindMagnitude_kts);
  J2_PACK_VAR(􏵶message􏵷->m_fWindHeading_deg);
  J2_PACK_VAR(􏵶message􏵷->m_fWindInclination_deg);
  J2_PACK_VAR(􏵶message􏵷->m_fTurbulence);
  J2_PACK_VAR(􏵶message􏵷->m_fPayloadWeight_lbs);
  J2_PACK_VAR(􏵶message􏵷->m_fCGOffsetX_in);
  J2_PACK_VAR(􏵶message􏵷->m_fCGOffsetY_in);
  J2_PACK_VAR(􏵶message􏵷->m_fCGOffsetZ_in);
    
  􏶲engine related packing􏶱
  J2_PACK_VAR(􏵶message􏵷->m_nNumberOfEngines);
  J2_PACK_PARTIAL_ARRAY(􏵶message􏵷->m_pnEngineStarterRunning,􏵶message􏵷->m_nNumberOfEngines,MAX_NUMBER_OF_ENGINES);
  J2_PACK_PARTIAL_ARRAY(􏵶message􏵷->m_pnBleedAir,􏵶message􏵷->m_nNumberOfEngines,MAX_NUMBER_OF_ENGINES);
  J2_PACK_PARTIAL_ARRAY(􏵶message􏵷->m_pnIgnitionOn,􏵶message􏵷->m_nNumberOfEngines,MAX_NUMBER_OF_ENGINES);
  J2_PACK_PARTIAL_ARRAY(􏵶message􏵷->m_pnEngineFlags1,􏵶message􏵷->m_nNumberOfEngines,MAX_NUMBER_OF_ENGINES);
  J2_PACK_PARTIAL_ARRAY(􏵶message􏵷->m_pnEngineInletState,􏵶message􏵷->m_nNumberOfEngines,MAX_NUMBER_OF_ENGINES);
  J2_PACK_PARTIAL_ARRAY(􏵶message􏵷->m_fIceStatesEngine_in,􏵶message􏵷->m_nNumberOfEngines,MAX_NUMBER_OF_ENGINES);
  J2_PACK_PARTIAL_ARRAY(􏵶message􏵷->m_nEngineFailureFlags,􏵶message􏵷->m_nNumberOfEngines,MAX_NUMBER_OF_ENGINES);
  J2_PACK_PARTIAL_ARRAY(􏵶message􏵷->m_pfIceStatesProp_in,􏵶message􏵷->m_nNumberOfEngines,MAX_NUMBER_OF_ENGINES);
    
    
  J2_PACK_VAR(􏵶message􏵷->m_fIceStateRightWing_in);
  J2_PACK_VAR(􏵶message􏵷->m_fIceStateLeftWing_in);
  J2_PACK_VAR(􏵶message􏵷->m_fIceStateFuselage_in);
  J2_PACK_VAR(􏵶message􏵷->m_fIceStateTail_in);
  J2_PACK_VAR(􏵶message􏵷->m_nTimeMultiplier);
  J2_PACK_VAR(􏵶message􏵷->m_nFailureFlags1);
􏶳

􏷘-􏷗􏷒pack j2 reposition send message payload􏷑
􏷐pack the relevant data into the buffer􏷏
􏶠specific packing for reposition􏶡
􏶜􏶝􏷆BYTE *const􏷅􏷄buffer􏷃􏷀The data buffer to pack the message in􏶿
􏶜􏶝􏷆size_t*const􏷅􏷄buffer iterator􏷃􏷀the index of the buffer to start packing the data at􏶿
􏶜c􏶝􏷆SendRepositionMessageT *const􏷅􏷄message􏷃􏷀The message to pack􏶿
􏶴
  J2_PACK_VAR(􏵶message􏵷->m_nRepositionType);
  J2_PACK_VAR(􏵶message􏵷->m_dLatitude_deg);
  J2_PACK_VAR(􏵶message􏵷->m_dLongitude_deg);
  J2_PACK_VAR(􏵶message􏵷->m_dMSLAltitude_ft);
  J2_PACK_VAR(􏵶message􏵷->m_fMagneticHeading_deg);
  J2_PACK_VAR(􏵶message􏵷->m_fIndicatedAirspeed_kts);
  J2_PACK_VAR(􏵶message􏵷->m_fAircraftPitch_deg);
  J2_PACK_VAR(􏵶message􏵷->m_fAircraftRoll_deg);
  J2_PACK_VAR(􏵶message􏵷->m_fVerticalSpeed_ft_m);
    
    􏶲engine related packing􏶱
  J2_PACK_VAR(􏵶message􏵷->m_nNumberOfEngines);
    J2_PACK_PARTIAL_ARRAY(􏵶message􏵷->m_pnEngineRunning,􏵶message􏵷->m_nNumberOfEngines,MAX_NUMBER_OF_ENGINES);
    J2_PACK_PARTIAL_ARRAY(􏵶message􏵷->m_pfEngineRpm,􏵶message􏵷->m_nNumberOfEngines,MAX_NUMBER_OF_ENGINES);
    J2_PACK_PARTIAL_ARRAY(􏵶message􏵷->m_pfN1,􏵶message􏵷->m_nNumberOfEngines,MAX_NUMBER_OF_ENGINES);
    J2_PACK_PARTIAL_ARRAY(􏵶message􏵷->m_pfN2,􏵶message􏵷->m_nNumberOfEngines,MAX_NUMBER_OF_ENGINES);
    
    􏶲propeller related packing􏶱
  J2_PACK_VAR(􏵶message􏵷->m_nNumberOfPropellers);
    J2_PACK_PARTIAL_ARRAY(􏵶message􏵷->m_puPropellerRpm,􏵶message􏵷->m_nNumberOfPropellers,MAX_NUMBER_OF_PROPELLERS);
􏶳


􏷘-􏷗􏷒unpack j2 high speed send message payload􏷑
􏷐unpack the relevant data into the buffer􏷏
􏶠specific unpacking for high speed
Implemented in order to test the pack version􏶡
􏶜c􏶝􏷆BYTE *const􏷅􏷄buffer􏷃􏷀The data buffer to unpack the message in􏶿
􏶜􏶝􏷆size_t*const􏷅􏷄buffer iterator􏷃􏷀the index of the buffer to start unpacking the data at􏶿
􏶜􏶝􏷆SendHighSpeedMessageT *const􏷅􏷄message􏷃􏷀The message to unpack􏶿
􏶴
    J2_UNPACK_VAR(􏵶message􏵷->m_fPitchFlightControl);
    J2_UNPACK_VAR(􏵶message􏵷->m_fRollFlightControl);
    J2_UNPACK_VAR(􏵶message􏵷->m_fYawFlightControl);
    J2_UNPACK_VAR(􏵶message􏵷->m_fCollectiveFlightControl);
    J2_UNPACK_VAR(􏵶message􏵷->m_fPitchTrimPosition);
    J2_UNPACK_VAR(􏵶message􏵷->m_fRollTrimPosition);
    J2_UNPACK_VAR(􏵶message􏵷->m_fYawTrimPosition);
    J2_UNPACK_FULL_ARRAY(􏵶message􏵷->m_pfYawSerialActuators);
    J2_UNPACK_VAR(􏵶message􏵷->m_fYawTrimActuators);
    J2_UNPACK_FULL_ARRAY(􏵶message􏵷->m_pfRollSerialActuators);
    J2_UNPACK_VAR(􏵶message􏵷->m_fRollTrimActuators);
    J2_UNPACK_FULL_ARRAY(􏵶message􏵷->m_pfPitchSerialActuators);
    J2_UNPACK_VAR(􏵶message􏵷->m_fPitchTrimActuators);
    J2_UNPACK_FULL_ARRAY(􏵶message􏵷->m_pfCollectiveSerialActuators);
    J2_UNPACK_VAR(􏵶message􏵷->m_fCollectiveTrimActuators);
    J2_UNPACK_VAR(􏵶message􏵷->m_nYawControlOverrideFlag);
    J2_UNPACK_VAR(􏵶message􏵷->m_nPitchControlOverrideFlag);
    J2_UNPACK_VAR(􏵶message􏵷->m_nRollControlOverrideFlag);
    J2_UNPACK_VAR(􏵶message􏵷->m_nCollectiveControlOverrideFlag);
    J2_UNPACK_VAR(􏵶message􏵷->m_fRightBrakes);
    J2_UNPACK_VAR(􏵶message􏵷->m_fLeftBrakes);
    J2_UNPACK_VAR(􏵶message􏵷->m_fNoseWheelControl);
    J2_UNPACK_VAR(􏵶message􏵷->m_fRotorBrake);
    J2_UNPACK_VAR(􏵶message􏵷->m_nWinchFlag);
    J2_UNPACK_VAR(􏵶message􏵷->m_fWinchLength_m);
    J2_UNPACK_VAR(􏵶message􏵷->m_fWinchPayloadMass_kg);
    J2_UNPACK_VAR(􏵶message􏵷->m_fWinchPayloadX_m);
    J2_UNPACK_VAR(􏵶message􏵷->m_fWinchPayloadY_m);
    J2_UNPACK_VAR(􏵶message􏵷->m_fWinchPayloadZ_m);
    J2_UNPACK_VAR(􏵶message􏵷->m_nHookFlag);
    J2_UNPACK_VAR(􏵶message􏵷->m_fHookLength_m);
    J2_UNPACK_VAR(􏵶message􏵷->m_fHookPayloadMass_Kg);
    J2_UNPACK_VAR(􏵶message􏵷->m_fHookPayloadX_m);
    J2_UNPACK_VAR(􏵶message􏵷->m_fHookPayloadY_m);
    J2_UNPACK_VAR(􏵶message􏵷->m_fHookPayloadZ_m);
    J2_UNPACK_VAR(􏵶message􏵷->m_nSASMode);
    J2_UNPACK_VAR(􏵶message􏵷->m_fHeightAboveTerrain_feet);
    
    􏶲contact point packing􏶱
    J2_UNPACK_VAR(􏵶message􏵷->m_nNumberOfContactPoints);
    J2_UNPACK_PARTIAL_ARRAY(􏵶message􏵷->m_pfGroundContactLocation_feet,􏵶message􏵷->m_nNumberOfContactPoints,NUM_CONTACT_LOCATION);
    
    􏶲engine related unpacking􏶱
    J2_UNPACK_VAR(􏵶message􏵷->m_nNumberOfEngines);
    J2_UNPACK_PARTIAL_ARRAY(􏵶message􏵷->m_pfThrottle,􏵶message􏵷->m_nNumberOfEngines,MAX_NUMBER_OF_ENGINES);
    J2_UNPACK_PARTIAL_ARRAY(􏵶message􏵷->m_pfMixture,􏵶message􏵷->m_nNumberOfEngines,MAX_NUMBER_OF_ENGINES);
    
    􏶲propeller unpacking􏶱
    J2_UNPACK_VAR(􏵶message􏵷->m_nNumberOfPropellers);
    J2_UNPACK_PARTIAL_ARRAY(􏵶message􏵷->m_pfPropPitch_degrees,􏵶message􏵷->m_nNumberOfPropellers,MAX_NUMBER_OF_PROPELLERS);
    
    􏶲fuel tank unpacking􏶱
    J2_UNPACK_VAR(􏵶message􏵷->m_nNumberOfTanks);
    J2_UNPACK_PARTIAL_ARRAY(􏵶message􏵷->m_pfFuelWeight_lbs,􏵶message􏵷->m_nNumberOfTanks,MAX_NUMBER_OF_FUEL_TANKS);
    
    J2_UNPACK_VAR(􏵶message􏵷->m_nFlag1);
􏶳

􏷘-􏷗􏷒unpack j2 high speed received message payload􏷑
􏷐Used to unpack the incoming J2 high speed payload.􏷏
􏶠Called after receiving a J2 Message.􏶡
􏶜c􏶝􏷆BYTE *const􏷅􏷄buffer􏷃􏷀The data buffer to unpack the message from􏶿
􏶜􏶝􏷆size_t*const􏷅􏷄buffer iterator􏷃􏷀the index of the buffer to start unpacking the data at􏶿
􏶜􏶝􏷆RcvHighSpeedMessageT *const􏷅􏷄message􏷃􏷀The message to unpack􏶿
􏶴
    J2_UNPACK_VAR(􏵶message􏵷->m_dLatitude_deg);
    J2_UNPACK_VAR(􏵶message􏵷->m_dLongitude_deg);
    J2_UNPACK_VAR(􏵶message􏵷->m_dMSLAltitude_ft);
    J2_UNPACK_VAR(􏵶message􏵷->m_fTheta_deg);
    J2_UNPACK_VAR(􏵶message􏵷->m_fPsi_deg);
    J2_UNPACK_VAR(􏵶message􏵷->m_fBeta_deg);
    J2_UNPACK_VAR(􏵶message􏵷->m_fPhi_deg);
    J2_UNPACK_VAR(􏵶message􏵷->m_fAlpha_deg);
    J2_UNPACK_VAR(􏵶message􏵷->m_fSlip_deg);
    J2_UNPACK_VAR(􏵶message􏵷->m_fAngleOfAttack);
    J2_UNPACK_VAR(􏵶message􏵷->m_fVelocityX_mps);
    J2_UNPACK_VAR(􏵶message􏵷->m_fVelocityY_mps);
    J2_UNPACK_VAR(􏵶message􏵷->m_fVelocityZ_mps);
    J2_UNPACK_VAR(􏵶message􏵷->m_fAccelX_mpss);
    J2_UNPACK_VAR(􏵶message􏵷->m_fAccelY_mpss);
    J2_UNPACK_VAR(􏵶message􏵷->m_fAccelZ_mpss);
    J2_UNPACK_VAR(􏵶message􏵷->m_fPitchRate_dps);
    J2_UNPACK_VAR(􏵶message􏵷->m_fRollRate_dps);
    J2_UNPACK_VAR(􏵶message􏵷->m_fYawRate_dps);
    J2_UNPACK_VAR(􏵶message􏵷->m_fPitchAccel_dpss);
    J2_UNPACK_VAR(􏵶message􏵷->m_fRollAccel_dpss);
    J2_UNPACK_VAR(􏵶message􏵷->m_fYawAccel_dpss);
    J2_UNPACK_VAR(􏵶message􏵷->m_fTrueAirspeed_kts);
    J2_UNPACK_VAR(􏵶message􏵷->m_fGroundSpeed_kts);
    J2_UNPACK_VAR(􏵶message􏵷->m_fVerticalSpeed_fpm);
    J2_UNPACK_VAR(􏵶message􏵷->m_fIndicatedAirspeed_kts);
    J2_UNPACK_VAR(􏵶message􏵷->m_fMachNumber);
    J2_UNPACK_VAR(􏵶message􏵷->m_fNorthVelocity_kts);
    J2_UNPACK_VAR(􏵶message􏵷->m_fEastVelocity_kts);
    J2_UNPACK_VAR(􏵶message􏵷->m_fDynamicPressure_Pa);
    J2_UNPACK_VAR(􏵶message􏵷->m_fMagneticHeading_deg);
    
    
    􏶲landing gear unpacking􏶱
    J2_UNPACK_VAR(􏵶message􏵷->m_nNumberOfLandingGears);
    J2_UNPACK_PARTIAL_ARRAY(􏵶message􏵷->m_pfWeightOnLandingGear_lbs,􏵶message􏵷->m_nNumberOfLandingGears,MAX_NUMBER_OF_LANDING_GEARS);
    
    
    J2_UNPACK_VAR(􏵶message􏵷->m_nFlag1);
    J2_UNPACK_VAR(􏵶message􏵷->m_fPilotSeatCgOffsetX_m);
    J2_UNPACK_VAR(􏵶message􏵷->m_fPilotSeatCgOffsetY_m);
    J2_UNPACK_VAR(􏵶message􏵷->m_fPilotSeatCgOffsetZ_m);
    J2_UNPACK_VAR(􏵶message􏵷->m_fCoPilotSeatCgOffsetX_m);
    J2_UNPACK_VAR(􏵶message􏵷->m_fCoPilotSeatCgOffsetY_m);
    J2_UNPACK_VAR(􏵶message􏵷->m_fCoPilotSeatCgOffsetZ_m);
    J2_UNPACK_FULL_ARRAY(􏵶message􏵷->m_pfYawSerialActuators);
    J2_UNPACK_VAR(􏵶message􏵷->m_fYawTrimActuators);
    J2_UNPACK_FULL_ARRAY(􏵶message􏵷->m_pfRollSerialActuators);
    J2_UNPACK_VAR(􏵶message􏵷->m_fRollTrimActuators);
    J2_UNPACK_FULL_ARRAY(􏵶message􏵷->m_pfPitchSerialActuators);
    J2_UNPACK_VAR(􏵶message􏵷->m_fPitchTrimActuators);
    J2_UNPACK_FULL_ARRAY(􏵶message􏵷->m_pfCollectiveSerialActuators);
    J2_UNPACK_VAR(􏵶message􏵷->m_fCollectiveTrimActuators);
    
    􏶲surface unpacking􏶱
    J2_UNPACK_VAR(􏵶message􏵷->m_nNumberOfSurfaces);
    J2_UNPACK_PARTIAL_ARRAY(􏵶message􏵷->m_pfSurfaceQ,􏵶message􏵷->m_nNumberOfSurfaces,MAX_NUMBER_OF_SURFACES);
    J2_UNPACK_PARTIAL_ARRAY(􏵶message􏵷->m_pfSurfaceAngleOfIncidence,􏵶message􏵷->m_nNumberOfSurfaces,MAX_NUMBER_OF_SURFACES);
    J2_UNPACK_PARTIAL_ARRAY(􏵶message􏵷->m_pfSurfaceTorque,􏵶message􏵷->m_nNumberOfSurfaces,MAX_NUMBER_OF_SURFACES);
    
    J2_UNPACK_VAR(􏵶message􏵷->m_fBuffetMagnitude);
    
    􏶲spare bucket unpacking􏶱
    J2_UNPACK_VAR(􏵶message􏵷->m_nSpareBucketSize);
    J2_UNPACK_PARTIAL_ARRAY(􏵶message􏵷->m_pfSpareBucket,􏵶message􏵷->m_nSpareBucketSize,MAX_SPARE_BUCKET_SIZE);
􏶳

􏷘-􏷗􏷒unpack j2 low speed received message payload􏷑
􏷐Used to unpack the incoming J2 low speed payload.􏷏
􏶠Called after receiving a J2 Message.􏶡
􏶜c􏶝􏷆BYTE *const􏷅􏷄buffer􏷃􏷀The data buffer to unpack the message from􏶿
􏶜􏶝􏷆size_t*const􏷅􏷄buffer iterator􏷃􏷀the index of the buffer to start unpacking the data at􏶿
􏶜􏶝􏷆RcvLowSpeedMessageT *const􏷅􏷄message􏷃􏷀The message to unpack􏶿
􏶴
    J2_UNPACK_VAR(􏵶message􏵷->m_fOutsideAirTemperature_degf);
    J2_UNPACK_VAR(􏵶message􏵷->m_fOutsideAirPressure_inHg);
    J2_UNPACK_VAR(􏵶message􏵷->m_fNoseWheelPosition_deg);
    J2_UNPACK_VAR(􏵶message􏵷->m_fMagneticVariation_deg);
􏶳

􏷘-􏷗􏷒unpack j2 engine received message payload􏷑
􏷐Used to unpack the incoming J2 engine payload.􏷏
􏶠Called after receiving a J2 Message.􏶡
􏶜c􏶝􏷆BYTE *const􏷅􏷄buffer􏷃􏷀The data buffer to unpack the message from􏶿
􏶜􏶝􏷆size_t*const􏷅􏷄buffer iterator􏷃􏷀the index of the buffer to start unpacking the data at􏶿
􏶜􏶝􏷆RcvEngineDataMessageT *const􏷅􏷄message􏷃􏷀The message to unpack􏶿
􏶴
    size_t uIndex = 0;
    J2_UNPACK_VAR(􏵶message􏵷->m_nNumberOfEngines);
    
    for(; uIndex < 􏵶message􏵷->m_nNumberOfEngines && uIndex < MAX_NUMBER_OF_ENGINES; ++uIndex){
        J2_UNPACK_VAR(􏵶message􏵷->m_ptEngine[uIndex].m_fN1_pct);
        J2_UNPACK_VAR(􏵶message􏵷->m_ptEngine[uIndex].m_fN2_pct);
        J2_UNPACK_VAR(􏵶message􏵷->m_ptEngine[uIndex].m_fTorque_ftlbs);
        J2_UNPACK_VAR(􏵶message􏵷->m_ptEngine[uIndex].m_fFuelFlow_pph);
        J2_UNPACK_VAR(􏵶message􏵷->m_ptEngine[uIndex].m_fOilTemperature_degf);
        J2_UNPACK_VAR(􏵶message􏵷->m_ptEngine[uIndex].m_fOilPressure_psi);
        J2_UNPACK_VAR(􏵶message􏵷->m_ptEngine[uIndex].m_fExhaustGasTemperature_degf);
        J2_UNPACK_VAR(􏵶message􏵷->m_ptEngine[uIndex].m_fCylinderHeadTemperature_degf);
        J2_UNPACK_VAR(􏵶message􏵷->m_ptEngine[uIndex].m_fEngineRPM);
        J2_UNPACK_VAR(􏵶message􏵷->m_ptEngine[uIndex].m_fEngineThrust_lbs);
        J2_UNPACK_VAR(􏵶message􏵷->m_ptEngine[uIndex].m_fManifoldPressure_inHg);
        J2_UNPACK_VAR(􏵶message􏵷->m_ptEngine[uIndex].m_fInletTurbineTemperature_degc);
        J2_UNPACK_VAR(􏵶message􏵷->m_ptEngine[uIndex].m_fBleedAirPressureGenerated_psi);
    }

    J2_UNPACK_VAR(􏵶message􏵷->m_nNumberOfPropellers);

    uIndex = 0;
    for(; uIndex < 􏵶message􏵷->m_nNumberOfPropellers && uIndex < MAX_NUMBER_OF_PROPELLERS; ++uIndex){
        J2_UNPACK_VAR(􏵶message􏵷->m_ptPropeller[uIndex].m_fPropRPM);
        J2_UNPACK_VAR(􏵶message􏵷->m_ptPropeller[uIndex].m_fPropPitch_deg);
        J2_UNPACK_VAR(􏵶message􏵷->m_ptPropeller[uIndex].m_fMastMomentDirection_deg);
        J2_UNPACK_VAR(􏵶message􏵷->m_ptPropeller[uIndex].m_fMastMomentForce_Nm);
    }
􏶳

􏷘-􏷗􏷒unpack j2 reposition received message payload􏷑
􏷐Used to unpack the incoming J2 reposition payload.􏷏
􏶠Called after receiving a J2 Message.􏶡
􏶜c􏶝􏷆BYTE *const􏷅􏷄buffer􏷃􏷀The data buffer to unpack the message from􏶿
􏶜􏶝􏷆size_t*const􏷅􏷄buffer iterator􏷃􏷀the index of the buffer to start unpacking the data at􏶿
􏶜􏶝􏷆RepositionMessageReplyT *const􏷅􏷄message􏷃􏷀The message to unpack􏶿
􏶴
    J2_UNPACK_VAR(􏵶message􏵷->m_fYawControlPosition);
    J2_UNPACK_VAR(􏵶message􏵷->m_fThrottlePosition);
    J2_UNPACK_VAR(􏵶message􏵷->m_fLateralControlPosition);
    J2_UNPACK_VAR(􏵶message􏵷->m_fLongitudinalControlPosition);
􏶳

􏷘-􏷗􏷒unpack j2 version received message payload􏷑
􏷐Used to unpack the incoming J2 version request payload.􏷏
􏶠Called after receiving a J2 Message.􏶡
􏶜c􏶝􏷆BYTE *const􏷅􏷄buffer􏷃􏷀The data buffer to unpack the message from􏶿
􏶜􏶝􏷆size_t*const􏷅􏷄buffer iterator􏷃􏷀the index of the buffer to start unpacking the data at􏶿
􏶜􏶝􏷆VersionMessageReplyT *const􏷅􏷄message􏷃􏷀The message to unpack􏶿
􏶴
    J2_UNPACK_VAR(􏵶message􏵷->m_fJ2Version);
    J2_UNPACK_VAR(􏵶message􏵷->m_fAircraftModel);
    
    􏶲dev item unpacking􏶱
    J2_UNPACK_VAR(􏵶message􏵷->m_nNumberOfDeveloperItems);
    J2_UNPACK_PARTIAL_ARRAY(􏵶message􏵷->m_szDevItem,􏵶message􏵷->m_nNumberOfDeveloperItems,MAX_DEV_ITEMS);
􏶳




















􏷘-􏷗􏷒pack header􏷑
􏷐Used to fill the buffer header that comes before the payload.􏷏
􏶠The byte count portion is filled based on the iterated payload􏶡
􏶜􏶝􏷆BYTE *const􏷅􏷄buffer􏷃􏷀The data buffer to pack the message in􏶿
􏶜􏶝􏷆size_t􏷅􏷄buffer iterator􏷃􏷀the index of the buffer to start packing the data at􏶿
􏶜c􏶝􏷆SimhostToJ2MessageTypeE􏷅􏷄message type􏷃􏷀The message to pack􏶿
􏶴
    􏶲the header of the message is 4 bytes􏶱
    
    􏶲the first byte is the message type􏶱
    BYTE pucHeader[4];
    size_t uIndex = 0;
    short sSpecifiedSize;
    switch (􏵶message type􏵷){
        case SIMHOST_TO_J2_MESSAGE_TYPE_HIGH_SPEED: pucHeader[0] = 1; break;
        case SIMHOST_TO_J2_MESSAGE_TYPE_LOW_SPEED: pucHeader[0] = 2; break;
        case SIMHOST_TO_J2_MESSAGE_TYPE_REPOSITION: pucHeader[0] = 3; break;
        case SIMHOST_TO_J2_MESSAGE_TYPE_VERSION: pucHeader[0] = 4; break;
        default: fprintf(stderr,"invalid message type requested for J2 header");
    }
    
    􏶲the next two bytes are the total byte count􏶱
    􏶲(this gets derived from filling the payload + an extra 4 bytes for the header itself)􏶱
    uIndex=1;
    sSpecifiedSize = (short)􏵶buffer iterator􏵷;
    PackBigEndian4ByteInvariance(pucHeader,&uIndex,&sSpecifiedSize,sizeof(short));
    
    􏶲the last byte is the version number􏶱
    pucHeader[3] = 1;
    uIndex = 0;
    PackBigEndian4ByteInvariance(􏵶buffer􏵷,&uIndex,pucHeader,sizeof(pucHeader));
􏶳

􏷘-􏷗􏷒unpack header􏷑
􏷐Used to unpack the buffer header that comes before the payload.􏷏
􏶠returns the header which is a known size􏶡
􏶜c􏶝􏷆BYTE *const􏷅􏷄buffer􏷃􏷀The data buffer to pack the message in􏶿
􏶾J2MessageHeaderT􏶽􏶼header􏶻􏶺The header of the message􏶹
􏶴
    􏶲the header portion before the payload􏶱
    J2MessageHeaderT tHeader;
    short sSpecifiedSize;
    
    􏶲the starting unpack iterator of the buffer􏶱
    􏶲we start at 1, because we already know the message type􏶱
    size_t uByteIterator = 1;
    
    􏶲store the byte count to verify at the end of unpacking􏶱
    memcpy(&sSpecifiedSize,&􏵶buffer􏵷[uByteIterator],2);
    tHeader.m_uByteCount = sSpecifiedSize;
    
    􏶲the message version􏶱
    tHeader.m_ucMessageVersion = 􏵶buffer􏵷[uByteIterator];

    return tHeader;
􏶳