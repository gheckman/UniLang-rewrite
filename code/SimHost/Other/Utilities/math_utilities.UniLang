􏶞g􏶟
􏷲math related utilities􏷱
􏷰generic math related functions not found in math.h􏷯
􏷮Math Utilities􏷭􏷮Utilities􏷭
􏷬Trevor Hickey􏷫
􏷤s􏷣􏷦stddef􏷥􏷢USES: size_t􏷡
􏷤s􏷣􏷦stdioLib􏷥􏷢USES: BOOL􏷡
􏶔s􏶕􏶒math􏶓􏶖USES: sqrt(), fabs()􏶗
􏶔s􏶕􏶒float.h􏶓􏶖USES: FLT_EPSILON, DBL_EPSILON􏶗

􏷘+􏷗􏷒f min f􏷑
􏷐Calculates the minimum of two floating point numbers􏷏
􏶠This function would normally exist in math.h, but we are using C89 and not C9X􏶡
􏶜􏶝􏷆float􏷅􏷄x􏷃􏷀one of the numbers to compare against􏶿
􏶜􏶝􏷆float􏷅􏷄y􏷃􏷀one of the numbers to compare against􏶿
􏶚m􏶛􏶾float􏶽􏶼max􏶻􏶺the maximum of the two numbers􏶹
􏶴
    return (􏵶x􏵷 < 􏵶y􏵷) ? 􏵶x􏵷 : 􏵶y􏵷;
􏶳

􏷘+􏷗􏷒f max f􏷑
􏷐Calculates the maximum of two floating point numbers􏷏
􏶠This function would normally exist in math.h, but we are using C89 and not C9X􏶡
􏶜􏶝􏷆float􏷅􏷄x􏷃􏷀one of the numbers to compare against􏶿
􏶜􏶝􏷆float􏷅􏷄y􏷃􏷀one of the numbers to compare against􏶿
􏶚m􏶛􏶾float􏶽􏶼max􏶻􏶺the minimum of the two numbers􏶹
􏶴
    return (􏵶x􏵷 > 􏵶y􏵷) ? 􏵶x􏵷 : 􏵶y􏵷;
􏶳

􏷘+􏷗􏷒f min􏷑
􏷐Calculates the minimum of two floating point numbers􏷏
􏶠This function would normally exist in math.h, but we are using C89 and not C9X􏶡
􏶜􏶝􏷆double􏷅􏷄x􏷃􏷀one of the numbers to compare against􏶿
􏶜􏶝􏷆double􏷅􏷄y􏷃􏷀one of the numbers to compare against􏶿
􏶚m􏶛􏶾double􏶽􏶼max􏶻􏶺the maximum of the two numbers􏶹
􏶴
    return (􏵶x􏵷 < 􏵶y􏵷) ? 􏵶x􏵷 : 􏵶y􏵷;
􏶳

􏷘+􏷗􏷒f max􏷑
􏷐Calculates the maximum of two floating point numbers􏷏
􏶠This function would normally exist in math.h, but we are using C89 and not C9X􏶡
􏶜􏶝􏷆double􏷅􏷄x􏷃􏷀one of the numbers to compare against􏶿
􏶜􏶝􏷆double􏷅􏷄y􏷃􏷀one of the numbers to compare against􏶿
􏶚m􏶛􏶾double􏶽􏶼max􏶻􏶺the minimum of the two numbers􏶹
􏶴
    return (􏵶x􏵷 > 􏵶y􏵷) ? 􏵶x􏵷 : 􏵶y􏵷;
􏶳


􏷘+􏷗􏷒approximately equal f􏷑
􏷐Since floating point math is imprecise, checking for float equality after operations, will often leads to unexpected results􏷏
􏶠approximates the equality of two floating point numbers using the std float epsilon􏶡
􏶜􏶝􏷆float􏷅􏷄x􏷃􏷀one of the numbers used to test equality􏶿
􏶜􏶝􏷆float􏷅􏷄y􏷃􏷀one of the numbers used to test equality􏶿
􏶚m􏶛􏶾BOOL􏶽􏶼equal􏶻􏶺whether the two numbers are approximately equal􏶹
􏶴
    return fabs(􏵶x􏵷 - 􏵶y􏵷) <= 􏵲f max f􏵳fabs(􏵶x􏵷),fabs(􏵶y􏵷)) * FLT_EPSILON;
􏶳

􏷘+􏷗􏷒approximately greater equal f􏷑
􏷐Since floating point math is imprecise, checking for float equality after operations, will often leads to unexpected results􏷏
􏶠approximates if one float is >= to another using the std float epsilon􏶡
􏶜􏶝􏷆float􏷅􏷄left􏷃􏷀left operand􏶿
􏶜􏶝􏷆float􏷅􏷄right􏷃􏷀right operand􏶿
􏶚m􏶛􏶾BOOL􏶽􏶼equal􏶻􏶺whether the left operand is approximately >= to the right operand􏶹
􏶴
    return 􏵲approximately equal f􏵳􏵶left􏵷,􏵶right􏵷) || 􏵶left􏵷 > 􏵶right􏵷;
􏶳

􏷘+􏷗􏷒approximately less equal f􏷑
􏷐Since floating point math is imprecise, checking for float equality after operations, will often leads to unexpected results􏷏
􏶠approximates if one float is <= to another using the std float epsilon􏶡
􏶜􏶝􏷆float􏷅􏷄left􏷃􏷀left operand􏶿
􏶜􏶝􏷆float􏷅􏷄right􏷃􏷀right operand􏶿
􏶚m􏶛􏶾BOOL􏶽􏶼equal􏶻􏶺whether the left operand is approximately <= to the right operand􏶹
􏶴
    return 􏵲approximately equal f􏵳􏵶left􏵷,􏵶right􏵷) || 􏵶left􏵷 < 􏵶right􏵷;
􏶳

􏷘+􏷗􏷒approximately equal d􏷑
􏷐Since floating point math is imprecise, checking for float equality after operations, will often leads to unexpected results􏷏
􏶠approximates the equality of two floating point numbers using the std double epsilon􏶡
􏶜􏶝􏷆double􏷅􏷄x􏷃􏷀one of the numbers used to test equality􏶿
􏶜􏶝􏷆double􏷅􏷄y􏷃􏷀one of the numbers used to test equality􏶿
􏶚m􏶛􏶾BOOL􏶽􏶼equal􏶻􏶺whether the two numbers are approximately equal􏶹
􏶴
    return fabs(􏵶x􏵷 - 􏵶y􏵷) <= 􏵲f max􏵳fabs(􏵶x􏵷),fabs(􏵶y􏵷)) * DBL_EPSILON;
􏶳

􏷘+􏷗􏷒approximately greater equal d􏷑
􏷐Since floating point math is imprecise, checking for float equality after operations, will often leads to unexpected results􏷏
􏶠approximates if one double is >= to another using the std double epsilon􏶡
􏶜􏶝􏷆float􏷅􏷄left􏷃􏷀left operand􏶿
􏶜􏶝􏷆float􏷅􏷄right􏷃􏷀right operand􏶿
􏶚m􏶛􏶾BOOL􏶽􏶼equal􏶻􏶺whether the left operand is approximately >= to the right operand􏶹
􏶴
    return 􏵲approximately equal d􏵳􏵶left􏵷,􏵶right􏵷) || 􏵶left􏵷 > 􏵶right􏵷;
􏶳

􏷘+􏷗􏷒approximately less equal d􏷑
􏷐Since floating point math is imprecise, checking for float equality after operations, will often leads to unexpected results􏷏
􏶠approximates if one double is <= to another using the std double epsilon􏶡
􏶜􏶝􏷆float􏷅􏷄left􏷃􏷀left operand􏶿
􏶜􏶝􏷆float􏷅􏷄right􏷃􏷀right operand􏶿
􏶚m􏶛􏶾BOOL􏶽􏶼equal􏶻􏶺whether the left operand is approximately <= to the right operand􏶹
􏶴
    return 􏵲approximately equal d􏵳􏵶left􏵷,􏵶right􏵷) || 􏵶left􏵷 < 􏵶right􏵷;
􏶳







􏷘+􏷗􏷒float array average􏷑
􏷐takes the average of an array of floats􏷏
􏶠float specific function exists due to lack overloading/templates􏶡
􏶜􏶝􏷆float[]􏷅􏷄array􏷃􏷀array of numbers to average􏶿
􏶜􏶝􏷆size_t􏷅􏷄size􏷃􏷀the amount of elements to use when calculating the average􏶿
􏶚m􏶛􏶾float􏶽􏶼average􏶻􏶺the average of the selected elements􏶹
􏵪􏵫􏵨size must be <= the size of the array􏵩
􏶴

    float fTotal = 0.0f;
    size_t uIndex = 0u;
    
    􏶲if there are no elements, the average will be 0􏶱
    if(􏵶size􏵷 == 0){
        return 0.0f;
    }
    
    for (; uIndex < 􏵶size􏵷; ++uIndex){
        fTotal += 􏵶array􏵷[uIndex];
    }
    return fTotal / 􏵶size􏵷;
􏶳

􏷘+􏷗􏷒int array average􏷑
􏷐takes the average of an array of ints􏷏
􏶠int specific function exists due to lack overloading/templates􏶡
􏶜􏶝􏷆int[]􏷅􏷄array􏷃􏷀array of numbers to average􏶿
􏶜􏶝􏷆size_t􏷅􏷄size􏷃􏷀the amount of elements to use when calculating the average􏶿
􏶚m􏶛􏶾int􏶽􏶼average􏶻􏶺the average of the selected elements􏶹
􏵪􏵫􏵨size must be <= the size of the array􏵩
􏶴

    int nTotal = 0;
    size_t uIndex = 0u;
    
    􏶲if there are no elements, the average will be 0􏶱
    if(􏵶size􏵷 == 0){
        return 0;
    }
    
    for (; uIndex < 􏵶size􏵷; ++uIndex){
        nTotal += 􏵶array􏵷[uIndex];
    }
    return nTotal / 􏵶size􏵷;
􏶳




􏷘+􏷗􏷒square􏷑
􏷐squares a number􏷏
􏶠n*n􏶡
􏶜􏶝􏷆float􏷅􏷄number􏷃􏷀the number to square􏶿
􏶚m􏶛􏶾float􏶽􏶼square􏶻􏶺the squared number􏶹
􏶴
    return 􏵶number􏵷*􏵶number􏵷;
􏶳

􏷘+􏷗􏷒dot product􏷑
􏷐takes the dot product of two vectors􏷏
􏶠assumes they are the same dimension on shared param􏶡
􏶜􏶝􏷆float[]􏷅􏷄vector1􏷃􏷀a vector to use in the dot product􏶿
􏶜􏶝􏷆float[]􏷅􏷄vector2􏷃􏷀a vector to use in the dot product􏶿
􏶜􏶝􏷆size_t􏷅􏷄dimension􏷃􏷀the dimension of the two vectors􏶿
􏶚m􏶛􏶾float􏶽􏶼dot product􏶻􏶺the dot product of the two elements􏶹
􏶴
    size_t uIndex = 0u;
    float fProduct = 0.0f;
    for (; uIndex < 􏵶dimension􏵷; ++uIndex){
        fProduct += 􏵶vector1􏵷[uIndex] * 􏵶vector2􏵷[uIndex];
    }
    return fProduct;
􏶳

􏷘+􏷗􏷒norm of vector􏷑
􏷐takes the norm of a vector􏷏
􏶠uses the dot product to calculate the norm of a vector􏶡
􏶜􏶝􏷆float[]􏷅􏷄vector􏷃􏷀a vector to get the norm of􏶿
􏶜􏶝􏷆size_t􏷅􏷄dimension􏷃􏷀the dimension of the vector􏶿
􏶚m􏶛􏶾float􏶽􏶼norm􏶻􏶺the norm of the vector􏶹
􏶴
    return sqrt(􏵲dot product􏵳􏵶vector􏵷,􏵶vector􏵷,􏵶dimension􏵷));
􏶳


􏷘+􏷗􏷒normalize vector􏷑
􏷐normalizes a vector􏷏
􏶠􏶡
􏶜m􏶝􏷆float[]􏷅􏷄vector􏷃􏷀the vector to normalize􏶿
􏶜􏶝􏷆size_t􏷅􏷄dimension􏷃􏷀the dimension of the vector􏶿
􏶴
    float fMagnitude = 􏵲norm of vector􏵳􏵶vector􏵷,􏵶dimension􏵷);
    size_t uIndex = 0u;
    for (;uIndex < 􏵶dimension􏵷; ++uIndex)
    {
        􏵶vector􏵷[uIndex] /= fMagnitude;
    }
􏶳

􏷘-􏷗􏷒swap f􏷑
􏷐swaps two values􏷏
􏶠􏶡
􏶜rm􏶝􏷆float􏷅􏷄x􏷃􏷀one of the values to swap􏶿
􏶜rm􏶝􏷆float􏷅􏷄y􏷃􏷀one of the values to swap􏶿
􏶴
    float fTemp = *􏵶x􏵷;
    *􏵶x􏵷 = *􏵶y􏵷;
    *􏵶y􏵷 = fTemp;
􏶳

􏷘-􏷗􏷒order interval end points􏷑
􏷐swaps the two interval endpoints so that the begin endpoint has a smaller magnitude than the end endpoint􏷏
􏶠This is done to ensure that a value is properly compared in open/closed intervals􏶡
􏶜rm􏶝􏷆float􏷅􏷄begin interval􏷃􏷀the first value of the interval􏶿
􏶜rm􏶝􏷆float􏷅􏷄end interval􏷃􏷀the last value of the interval􏶿
􏶴
    􏶲potentially swap the interval end points to ensure we compare the value properly􏶱
    if (*􏵶begin interval􏵷 > *􏵶end interval􏵷){
        􏵲swap f􏵳􏵶begin interval􏵷,􏵶end interval􏵷);
    }
􏶳


􏷘+􏷗􏷒between closed interval􏷑
􏷐checks to see if a number is in between an inclusive range􏷏
􏶠uses float approximation to avoid precision errors
returns 􏵱 if it is, 􏵰 if it is not􏶡
􏶜􏶝􏷆float􏷅􏷄value􏷃􏷀the value to be checked with an interval􏶿
􏶜􏶝􏷆float􏷅􏷄begin interval􏷃􏷀the first value of the interval􏶿
􏶜􏶝􏷆float􏷅􏷄end interval􏷃􏷀the last value of the interval􏶿
􏶚m􏶛􏶾BOOL􏶽􏶼between interval􏶻􏶺whether the number passed in, is in between the specified interval􏶹
􏶴
    
    􏶲potentially swap the interval end points to ensure we compare the value properly􏶱
    􏵲order interval end points􏵳&􏵶begin interval􏵷,&􏵶end interval􏵷);
    
    return 􏵲approximately greater equal f􏵳􏵶value􏵷,􏵶begin interval􏵷) && 􏵲approximately less equal f􏵳􏵶value􏵷,􏵶end interval􏵷);
􏶳

􏷘+􏷗􏷒between open interval􏷑
􏷐checks to see if a number is in between an exclusive range􏷏
􏶠returns 􏵱 if it is, 􏵰 if it is not􏶡
􏶜􏶝􏷆float􏷅􏷄value􏷃􏷀the value to be checked with an interval􏶿
􏶜􏶝􏷆float􏷅􏷄begin interval􏷃􏷀the first value of the interval􏶿
􏶜􏶝􏷆float􏷅􏷄end interval􏷃􏷀the last value of the interval􏶿
􏶚m􏶛􏶾BOOL􏶽􏶼between interval􏶻􏶺whether the number passed in, is in between the specified interval􏶹
􏶴
    􏶲potentially swap the interval end points to ensure we compare the value properly􏶱
    􏵲order interval end points􏵳&􏵶begin interval􏵷,&􏵶end interval􏵷);
    
    return 􏵶value􏵷 > 􏵶begin interval􏵷 && 􏵶value􏵷 < 􏵶end interval􏵷;
􏶳
