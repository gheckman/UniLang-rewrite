􏶞g􏶟
􏷲Utilities for packing / unpacking on network data buffers􏷱
􏷰Deals with endianness and address invariance. not padding/offsets
Relies on architecture for endianness􏷯
􏷮Pack Utilities􏷭 􏷮Network􏷭 􏷮Utilities􏷭
􏷬Dave Corapi􏷫
􏷬Trevor Hickey􏷫
􏷤􏷣􏷦Defs.h􏷥􏷢USES: BYTE􏷡
􏷤􏷣􏷦stddef.h􏷥􏷢USES: size_t􏷡
􏷤􏷣􏷦stdioLib.h􏷥􏷢USES: BOOL􏷡
􏶔􏶕􏶒FfsCommon.h􏶓􏶖USES: DwordReverseByteOrder􏶗
􏶔􏶕􏶒strLib.h􏶓􏶖USES: memcpy()􏶗

􏷘+􏷗􏷒pack big endian 4 byte invariance􏷑
􏷐Packs a type into a big endian data buffer􏷏
􏶠DWORDs are revered if needed􏶡
􏶜􏶝􏷆BYTE*const􏷅􏷄buffer􏷃􏷀Reference to data buffer􏶿
􏶜􏶝􏷆size_t*const􏷅􏷄buffer iterator􏷃􏷀the index of the buffer to start packing the data at􏶿
􏶜c􏶝􏷆void*const􏷅􏷄data􏷃􏷀Data to be copied into buffer􏶿
􏶜c􏶝􏷆size_t􏷅􏷄data size􏷃􏷀size of the data to be copied into buffer􏶿
􏵪uDataSize % 4 == 0􏵫􏵨data size should be divisible by 4􏵩
􏵦uBufferIterator != 0􏵧􏵤the buffer iterator will increment so that it can be used to pack the next set of data􏵥
􏶴
    􏶲pack data into the byte array􏶱
    memcpy(&􏵶buffer􏵷[*􏵶buffer iterator􏵷],􏵶data􏵷,􏵶data size􏵷);
    
    􏶲increment our buffer iterator for the next pack􏶱
    *􏵶buffer iterator􏵷+= 􏵶data size􏵷;
    
􏶳

􏷘+􏷗􏷒unpack big endian 4 byte invariance􏷑
􏷐Unpacks a type stored as big endian from a data buffer􏷏
􏶠unpacked􏶡
􏶜c􏶝􏷆BYTE*const􏷅􏷄buffer􏷃􏷀Reference to data buffer􏶿
􏶜􏶝􏷆size_t*const􏷅􏷄buffer iterator􏷃􏷀the index of the buffer to start packing the data at􏶿
􏶜􏶝􏷆void*const􏷅􏷄data􏷃􏷀Data to be copied into buffer􏶿
􏶜c􏶝􏷆size_t􏷅􏷄data size􏷃􏷀size of the data to be copied into buffer􏶿
􏵪uDataSize % 4 == 0􏵫􏵨data size should be divisible by 4􏵩
􏵦uBufferIterator != 0􏵧􏵤the buffer iterator will increment so that it can be used to unpack the next set of data􏵥
􏶴
    􏶲unpack data from byte array􏶱
    memcpy(􏵶data􏵷,&􏵶buffer􏵷[*􏵶buffer iterator􏵷],􏵶data size􏵷);
    
    􏶲increment our buffer iterator for the next unpack􏶱
    *􏵶buffer iterator􏵷+= 􏵶data size􏵷;
􏶳

􏷘+􏷗􏷒pack little endian 4 byte invariance􏷑
􏷐Packs a type into a little endian data buffer􏷏
􏶠􏶡
􏶜􏶝􏷆BYTE*const􏷅􏷄buffer􏷃􏷀Reference to data buffer􏶿
􏶜􏶝􏷆size_t*const􏷅􏷄buffer iterator􏷃􏷀the index of the buffer to start packing the data at􏶿
􏶜c􏶝􏷆void*const􏷅􏷄data􏷃􏷀Data to be copied into buffer􏶿
􏶜c􏶝􏷆size_t􏷅􏷄data size􏷃􏷀size of the data to be copied into buffer􏶿
􏵪uDataSize % 4 == 0􏵫􏵨data size should be divisible by 4􏵩
􏵦uBufferIterator != 0􏵧􏵤the buffer iterator will increment so that it can be used to pack the next set of data􏵥
􏶴
    􏶲pack data into the byte array􏶱
    memcpy(&􏵶buffer􏵷[*􏵶buffer iterator􏵷],􏵶data􏵷,􏵶data size􏵷);
    
    􏶲reverse the packed data so that it is in little endian􏶱
    DwordReverseByteOrder(&􏵶buffer􏵷[*􏵶buffer iterator􏵷],􏵶data size􏵷);
    
    􏶲increment our buffer iterator for the next pack􏶱
    *􏵶buffer iterator􏵷+= 􏵶data size􏵷;
􏶳

􏷘+􏷗􏷒unpack little endian 4 byte invariance􏷑
􏷐Unpacks a type stored as little endian from a data buffer􏷏
􏶠􏶡
􏶜c􏶝􏷆BYTE*const􏷅􏷄buffer􏷃􏷀Reference to data buffer􏶿
􏶜􏶝􏷆size_t*const􏷅􏷄buffer iterator􏷃􏷀the index of the buffer to start packing the data at􏶿
􏶜􏶝􏷆void*const􏷅􏷄data􏷃􏷀Data to be copied into buffer􏶿
􏶜c􏶝􏷆size_t􏷅􏷄data size􏷃􏷀size of the data to be copied into buffer􏶿
􏵪uDataSize % 4 == 0􏵫􏵨data size should be divisible by 4􏵩
􏵦uBufferIterator != 0􏵧􏵤the buffer iterator will increment so that it can be used to unpack the next set of data􏵥
􏶴
    􏶲unpack data from byte array􏶱
    memcpy(􏵶data􏵷,&􏵶buffer􏵷[*􏵶buffer iterator􏵷],􏵶data size􏵷);
    
    􏶲reverse the unpacked data so that it is back to big endian􏶱
    DwordReverseByteOrder(􏵶data􏵷,􏵶data size􏵷);

    􏶲increment our buffer iterator for the next unpack􏶱
    *􏵶buffer iterator􏵷+= 􏵶data size􏵷;
􏶳


􏷘+􏷗􏷒pack big endian 2 byte invariance􏷑
􏷐Packs a type into a big endian data buffer􏷏
􏶠􏶡
􏶜􏶝􏷆BYTE*const􏷅􏷄buffer􏷃􏷀Reference to data buffer􏶿
􏶜􏶝􏷆size_t*const􏷅􏷄buffer iterator􏷃􏷀the index of the buffer to start packing the data at􏶿
􏶜c􏶝􏷆void*const􏷅􏷄data􏷃􏷀Data to be copied into buffer􏶿
􏶜c􏶝􏷆size_t􏷅􏷄data size􏷃􏷀size of the data to be copied into buffer􏶿
􏵪uDataSize % 2 == 0􏵫􏵨data size should be divisible by 2􏵩
􏵦uBufferIterator != 0􏵧􏵤the buffer iterator will increment so that it can be used to pack the next set of data􏵥
􏶴
    􏶲pack data into the byte array􏶱
    memcpy(&􏵶buffer􏵷[*􏵶buffer iterator􏵷],􏵶data􏵷,􏵶data size􏵷);
    
    􏶲increment our buffer iterator for the next pack􏶱
    *􏵶buffer iterator􏵷+= 􏵶data size􏵷;
    
􏶳

􏷘+􏷗􏷒unpack big endian 2 byte invariance􏷑
􏷐Unpacks a type stored as big endian from a data buffer􏷏
􏶠􏶡
􏶜c􏶝􏷆BYTE*const􏷅􏷄buffer􏷃􏷀Reference to data buffer􏶿
􏶜􏶝􏷆size_t*const􏷅􏷄buffer iterator􏷃􏷀the index of the buffer to start packing the data at􏶿
􏶜􏶝􏷆void*const􏷅􏷄data􏷃􏷀Data to be copied into buffer􏶿
􏶜c􏶝􏷆size_t􏷅􏷄data size􏷃􏷀size of the data to be copied into buffer􏶿
􏵪uDataSize % 2 == 0􏵫􏵨data size should be divisible by 2􏵩
􏵦uBufferIterator != 0􏵧􏵤the buffer iterator will increment so that it can be used to unpack the next set of data􏵥
􏶴
    􏶲unpack data from byte array􏶱
    memcpy(􏵶data􏵷,&􏵶buffer􏵷[*􏵶buffer iterator􏵷],􏵶data size􏵷);
    
    􏶲increment our buffer iterator for the next unpack􏶱
    *􏵶buffer iterator􏵷+= 􏵶data size􏵷;
􏶳

􏷘+􏷗􏷒pack little endian 2 byte invariance􏷑
􏷐Packs a type into a little endian data buffer􏷏
􏶠􏶡
􏶜􏶝􏷆BYTE*const􏷅􏷄buffer􏷃􏷀Reference to data buffer􏶿
􏶜􏶝􏷆size_t*const􏷅􏷄buffer iterator􏷃􏷀the index of the buffer to start packing the data at􏶿
􏶜c􏶝􏷆void*const􏷅􏷄data􏷃􏷀Data to be copied into buffer􏶿
􏶜c􏶝􏷆size_t􏷅􏷄data size􏷃􏷀size of the data to be copied into buffer􏶿
􏵪uDataSize % 2 == 0􏵫􏵨data size should be divisible by 2􏵩
􏵦uBufferIterator != 0􏵧􏵤the buffer iterator will increment so that it can be used to pack the next set of data􏵥
􏶴
    􏶲pack data into the byte array􏶱
    memcpy(&􏵶buffer􏵷[*􏵶buffer iterator􏵷],􏵶data􏵷,􏵶data size􏵷);
    
    􏶲reverse the packed data so that it is in little endian􏶱
    ReverseByteOrder(&􏵶buffer􏵷[*􏵶buffer iterator􏵷],􏵶data size􏵷);
    
    􏶲increment our buffer iterator for the next pack􏶱
    *􏵶buffer iterator􏵷+= 􏵶data size􏵷;
􏶳

􏷘+􏷗􏷒unpack little endian 2 byte invariance􏷑
􏷐Unpacks a type stored as little endian from a data buffer􏷏
􏶠􏶡
􏶜c􏶝􏷆BYTE*const􏷅􏷄buffer􏷃􏷀Reference to data buffer􏶿
􏶜􏶝􏷆size_t*const􏷅􏷄buffer iterator􏷃􏷀the index of the buffer to start packing the data at􏶿
􏶜􏶝􏷆void*const􏷅􏷄data􏷃􏷀Data to be copied into buffer􏶿
􏶜c􏶝􏷆size_t􏷅􏷄data size􏷃􏷀size of the data to be copied into buffer􏶿
􏵪uDataSize % 2 == 0􏵫􏵨data size should be divisible by 2􏵩
􏵦uBufferIterator != 0􏵧􏵤the buffer iterator will increment so that it can be used to unpack the next set of data􏵥
􏶴
    􏶲unpack data from byte array􏶱
    memcpy(􏵶data􏵷,&􏵶buffer􏵷[*􏵶buffer iterator􏵷],􏵶data size􏵷);
    
    􏶲reverse the unpacked data so that it is back to big endian􏶱
    ReverseByteOrder(􏵶data􏵷,􏵶data size􏵷);

    􏶲increment our buffer iterator for the next unpack􏶱
    *􏵶buffer iterator􏵷+= 􏵶data size􏵷;
􏶳




















􏷘+􏷗􏷒pack 8 bools into a byte􏷑
􏷐Packs eight BOOLs into a single BYTE of a buffer􏷏
􏶠uses bit shifts on each index of the bool array
note: the bits will be in reverse order of the bools passed in
example: {􏵱,􏵱,􏵱,􏵱,􏵱,􏵱,􏵱,􏵰}
becomes: 01111111􏶡
􏶜􏶝􏷆BYTE*􏷅􏷄data buffer􏷃􏷀Reference to data buffer􏶿
􏶜􏶝􏷆BOOL*􏷅􏷄pack bools􏷃􏷀an array of 8 bools to pack into a byte􏶿
􏶾int􏶽􏶼number of bytes􏶻􏶺Number of bytes packed􏶹
􏶴
    *􏵶data buffer􏵷 = (BYTE)(((􏵶pack bools􏵷[7] << 7) & 0xFF) + ((􏵶pack bools􏵷[6] << 6) & 0xFF) + ((􏵶pack bools􏵷[5] << 5) & 0xFF)
                          + ((􏵶pack bools􏵷[4] << 4) & 0xFF) + ((􏵶pack bools􏵷[3] << 3) & 0xFF) + ((􏵶pack bools􏵷[2] << 2) & 0xFF) 
                          + ((􏵶pack bools􏵷[1] << 1) & 0xFF) + (􏵶pack bools􏵷[0] & 0xFF));
    return sizeof(BYTE);
􏶳

