􏶞g􏶟
􏷲Utilities for packing / unpacking on network data buffers􏷱
􏷰Deals with endianness and address invariance. not padding/offsets􏷯
􏷮Pack Utilities􏷭 􏷮Network􏷭 􏷮Utilities􏷭
􏷬Dave Corapi􏷫
􏷬Trevor Hickey􏷫
􏷤􏷣􏷦Defs.h􏷥􏷢USES: BYTE􏷡
􏷤􏷣􏷦stddef.h􏷥􏷢USES: size_t􏷡
􏷤􏷣􏷦stdioLib.h􏷥􏷢USES: BOOL, UINT16􏷡
􏶔􏶕􏶒FfsCommon.h􏶓􏶖USES: DwordReverseByteOrder􏶗
􏶔􏶕􏶒strLib.h􏶓􏶖USES: memcpy()􏶗


􏷘-􏷗􏷒on big endian architecture􏷑
􏷐determines if the machine is big endian􏷏
􏶠returns 􏵱 if it is big endian.  􏵰 if it is little endian􏶡
􏶚m􏶛􏶾BOOL􏶽􏶼is on big endian􏶻􏵜􏵝􏶺whether the machine is on big endian or not􏶹
􏶴
    union U { UINT16 m_u16; unsigned char m_ucC; };
    union U u;
    u.m_u16 = 1;
    u.m_ucC = 0;
    return !u.m_ucC;
􏶳

􏷘-􏷗􏷒on little endian architecture􏷑
􏷐determines if the machine is little endian􏷏
􏶠returns 􏵱 if it is little endian.  􏵰 if it is big endian􏶡
􏶚m􏶛􏶾BOOL􏶽􏶼is on big endian􏶻􏵜􏵝􏶺whether the machine is on big endian or not􏶹
􏶴
    return !􏵲on big endian architecture􏵳);
􏶳


􏷘-􏷗􏷒reverse endian by 4 bytes when on little endian machine􏷑
􏷐reverses endian for little endian machines only􏷏 
􏶠only performs transformations on a little endian machine􏶡 
􏶜m􏶝􏷆BYTE[]􏷅􏷄buffer􏷃􏷀Reference to data buffer whose endian will potentially be reversed􏶿
􏶜􏶝􏷆size_t􏷅􏷄buffer size􏷃􏷀the size of the buffer􏶿
􏵪uDataSize % 4 == 0􏵫􏵨data size should be divisible by 4􏵩
􏶴
    if (􏵲on little endian architecture􏵳)){
        DwordReverseByteOrder(􏵶buffer􏵷,􏵶buffer size􏵷);
    }
􏶳

􏷘-􏷗􏷒reverse endian by 4 bytes when on big endian machine􏷑
􏷐reverses endian for big endian machines only􏷏 
􏶠only performs transformations on a big endian machine􏶡 
􏶜m􏶝􏷆BYTE[]􏷅􏷄buffer􏷃􏷀Reference to data buffer whose endian will potentially be reversed􏶿
􏶜􏶝􏷆size_t􏷅􏷄buffer size􏷃􏷀the size of the buffer􏶿
􏵪uDataSize % 4 == 0􏵫􏵨data size should be divisible by 4􏵩
􏶴
    if (􏵲on big endian architecture􏵳)){
        DwordReverseByteOrder(􏵶buffer􏵷,􏵶buffer size􏵷);
    }
􏶳

􏷘-􏷗􏷒reverse endian by 2 bytes when on little endian machine􏷑
􏷐reverses endian for little endian machines only􏷏 
􏶠only performs transformations on a little endian machine􏶡 
􏶜m􏶝􏷆BYTE[]􏷅􏷄buffer􏷃􏷀Reference to data buffer whose endian will potentially be reversed􏶿
􏶜􏶝􏷆size_t􏷅􏷄buffer size􏷃􏷀the size of the buffer􏶿
􏵪uDataSize % 2 == 0􏵫􏵨data size should be divisible by 2􏵩
􏶴
    if (􏵲on little endian architecture􏵳)){
        ReverseByteOrder(􏵶buffer􏵷,􏵶buffer size􏵷);
    }
􏶳

􏷘-􏷗􏷒reverse endian by 2 bytes when on big endian machine􏷑
􏷐reverses endian for big endian machines only􏷏 
􏶠only performs transformations on a big endian machine􏶡 
􏶜m􏶝􏷆BYTE[]􏷅􏷄buffer􏷃􏷀Reference to data buffer whose endian will potentially be reversed􏶿
􏶜􏶝􏷆size_t􏷅􏷄buffer size􏷃􏷀the size of the buffer􏶿
􏵪uDataSize % 2 == 0􏵫􏵨data size should be divisible by 2􏵩
􏶴
    if (􏵲on big endian architecture􏵳)){
        ReverseByteOrder(􏵶buffer􏵷,􏵶buffer size􏵷);
    }
􏶳





􏷘+􏷗􏷒pack big endian 4 byte invariance􏷑
􏷐Packs a type into a big endian data buffer􏷏
􏶠the bytes of the type are converted to big endian with a 4 byte invariance􏶡
􏶜m􏶝􏷆BYTE[]􏷅􏷄buffer􏷃􏷀Reference to data buffer􏶿
􏶜mr􏶝􏷆size_t􏷅􏷄buffer iterator􏷃􏷀the index of the buffer to start packing the data at􏶿
􏶜r􏶝􏷆void􏷅􏷄data􏷃􏷀Data to be copied into buffer􏶿
􏶜􏶝􏷆size_t􏷅􏷄data size􏷃􏷀size of the data to be copied into buffer􏶿
􏵪uDataSize % 4 == 0􏵫􏵨data size should be divisible by 4􏵩
􏵦uBufferIterator != 0􏵧􏵤the buffer iterator will increment so that it can be used to pack the next set of data􏵥
􏶴
    􏶲pack data into the byte array􏶱
    memcpy(&􏵶buffer􏵷[*􏵶buffer iterator􏵷],􏵶data􏵷,􏵶data size􏵷);
    
    􏶲potentially reverse the packed data so that it is in big endian􏶱
    􏵲reverse endian by 4 bytes when on little endian machine􏵳&􏵶buffer􏵷[*􏵶buffer iterator􏵷],􏵶data size􏵷);
    
    􏶲increment our buffer iterator for the next pack􏶱
    *􏵶buffer iterator􏵷+= 􏵶data size􏵷;
    
􏶳

􏷘+􏷗􏷒unpack big endian 4 byte invariance􏷑
􏷐Unpacks a type stored as big endian from a data buffer􏷏
􏶠the bytes of the type are converted to big endian with a 4 byte invariance􏶡
􏶜􏶝􏷆BYTE[]􏷅􏷄buffer􏷃􏷀Reference to data buffer􏶿
􏶜mr􏶝􏷆size_t􏷅􏷄buffer iterator􏷃􏷀the index of the buffer to start packing the data at􏶿
􏶜mr􏶝􏷆void􏷅􏷄data􏷃􏷀Data to be copied into buffer􏶿
􏶜􏶝􏷆size_t􏷅􏷄data size􏷃􏷀size of the data to be copied into buffer􏶿
􏵪uDataSize % 4 == 0􏵫􏵨data size should be divisible by 4􏵩
􏵦uBufferIterator != 0􏵧􏵤the buffer iterator will increment so that it can be used to unpack the next set of data􏵥
􏶴
    􏶲unpack data from byte array􏶱
    memcpy(􏵶data􏵷,&􏵶buffer􏵷[*􏵶buffer iterator􏵷],􏵶data size􏵷);
    
    􏶲potentially reverse the unpacked data so that it is back to little endian􏶱
    􏵲reverse endian by 4 bytes when on little endian machine􏵳􏵶data􏵷,􏵶data size􏵷);
    
    􏶲increment our buffer iterator for the next unpack􏶱
    *􏵶buffer iterator􏵷+= 􏵶data size􏵷;
􏶳

􏷘+􏷗􏷒pack little endian 4 byte invariance􏷑
􏷐Packs a type into a little endian data buffer􏷏
􏶠the bytes of the type are converted to little endian with a 4 byte invariance􏶡
􏶜m􏶝􏷆BYTE[]􏷅􏷄buffer􏷃􏷀Reference to data buffer􏶿
􏶜mr􏶝􏷆size_t􏷅􏷄buffer iterator􏷃􏷀the index of the buffer to start packing the data at􏶿
􏶜r􏶝􏷆void􏷅􏷄data􏷃􏷀Data to be copied into buffer􏶿
􏶜􏶝􏷆size_t􏷅􏷄data size􏷃􏷀size of the data to be copied into buffer􏶿
􏵪uDataSize % 4 == 0􏵫􏵨data size should be divisible by 4􏵩
􏵦uBufferIterator != 0􏵧􏵤the buffer iterator will increment so that it can be used to pack the next set of data􏵥
􏶴
    􏶲pack data into the byte array􏶱
    memcpy(&􏵶buffer􏵷[*􏵶buffer iterator􏵷],􏵶data􏵷,􏵶data size􏵷);
    
    􏶲potentially reverse the packed data so that it is in little endian􏶱
    􏵲reverse endian by 4 bytes when on big endian machine􏵳&􏵶buffer􏵷[*􏵶buffer iterator􏵷],􏵶data size􏵷);
    
    􏶲increment our buffer iterator for the next pack􏶱
    *􏵶buffer iterator􏵷 += 􏵶data size􏵷;
􏶳

􏷘+􏷗􏷒unpack little endian 4 byte invariance􏷑
􏷐Unpacks a type stored as little endian from a data buffer􏷏
􏶠the bytes of the type are converted to little endian with a 4 byte invariance􏶡
􏶜􏶝􏷆BYTE[]􏷅􏷄buffer􏷃􏷀Reference to data buffer􏶿
􏶜mr􏶝􏷆size_t􏷅􏷄buffer iterator􏷃􏷀the index of the buffer to start packing the data at􏶿
􏶜mr􏶝􏷆void􏷅􏷄data􏷃􏷀Data to be copied into buffer􏶿
􏶜􏶝􏷆size_t􏷅􏷄data size􏷃􏷀size of the data to be copied into buffer􏶿
􏵪uDataSize % 4 == 0􏵫􏵨data size should be divisible by 4􏵩
􏵦uBufferIterator != 0􏵧􏵤the buffer iterator will increment so that it can be used to unpack the next set of data􏵥
􏶴
    􏶲unpack data from byte array􏶱
    memcpy(􏵶data􏵷,&􏵶buffer􏵷[*􏵶buffer iterator􏵷],􏵶data size􏵷);
    
    􏶲potentially reverse the unpacked data so that it is back to big endian􏶱
    􏵲reverse endian by 4 bytes when on big endian machine􏵳􏵶data􏵷,􏵶data size􏵷);

    􏶲increment our buffer iterator for the next unpack􏶱
    *􏵶buffer iterator􏵷+= 􏵶data size􏵷;
􏶳



























􏷘+􏷗􏷒pack big endian 2 byte invariance􏷑
􏷐Packs a type into a big endian data buffer􏷏
􏶠the bytes of the type are converted to big endian with a 2 byte invariance􏶡
􏶜m􏶝􏷆BYTE[]􏷅􏷄buffer􏷃􏷀Reference to data buffer􏶿
􏶜mr􏶝􏷆size_t􏷅􏷄buffer iterator􏷃􏷀the index of the buffer to start packing the data at􏶿
􏶜r􏶝􏷆void􏷅􏷄data􏷃􏷀Data to be copied into buffer􏶿
􏶜􏶝􏷆size_t􏷅􏷄data size􏷃􏷀size of the data to be copied into buffer􏶿
􏵪uDataSize % 2 == 0􏵫􏵨data size should be divisible by 2􏵩
􏵦uBufferIterator != 0􏵧􏵤the buffer iterator will increment so that it can be used to pack the next set of data􏵥
􏶴
    􏶲pack data into the byte array􏶱
    memcpy(&􏵶buffer􏵷[*􏵶buffer iterator􏵷],􏵶data􏵷,􏵶data size􏵷);
    
    􏶲potentially reverse the packed data so that it is in big endian􏶱
    􏵲reverse endian by 2 bytes when on little endian machine􏵳&􏵶buffer􏵷[*􏵶buffer iterator􏵷],􏵶data size􏵷);
    
    􏶲increment our buffer iterator for the next pack􏶱
    *􏵶buffer iterator􏵷+= 􏵶data size􏵷;
    
􏶳

􏷘+􏷗􏷒unpack big endian 2 byte invariance􏷑
􏷐Unpacks a type stored as big endian from a data buffer􏷏
􏶠the bytes of the type are converted to big endian with a 2 byte invariance􏶡
􏶜􏶝􏷆BYTE[]􏷅􏷄buffer􏷃􏷀Reference to data buffer􏶿
􏶜mr􏶝􏷆size_t􏷅􏷄buffer iterator􏷃􏷀the index of the buffer to start packing the data at􏶿
􏶜mr􏶝􏷆void􏷅􏷄data􏷃􏷀Data to be copied into buffer􏶿
􏶜􏶝􏷆size_t􏷅􏷄data size􏷃􏷀size of the data to be copied into buffer􏶿
􏵪uDataSize % 2 == 0􏵫􏵨data size should be divisible by 2􏵩
􏵦uBufferIterator != 0􏵧􏵤the buffer iterator will increment so that it can be used to unpack the next set of data􏵥
􏶴
    􏶲unpack data from byte array􏶱
    memcpy(􏵶data􏵷,&􏵶buffer􏵷[*􏵶buffer iterator􏵷],􏵶data size􏵷);
    
    􏶲potentially reverse the unpacked data so that it is back to little endian􏶱
    􏵲reverse endian by 2 bytes when on little endian machine􏵳􏵶data􏵷,􏵶data size􏵷);
    
    􏶲increment our buffer iterator for the next unpack􏶱
    *􏵶buffer iterator􏵷+= 􏵶data size􏵷;
􏶳

􏷘+􏷗􏷒pack little endian 2 byte invariance􏷑
􏷐Packs a type into a little endian data buffer􏷏
􏶠the bytes of the type are converted to little endian with a 2 byte invariance􏶡
􏶜m􏶝􏷆BYTE[]􏷅􏷄buffer􏷃􏷀Reference to data buffer􏶿
􏶜mr􏶝􏷆size_t􏷅􏷄buffer iterator􏷃􏷀the index of the buffer to start packing the data at􏶿
􏶜r􏶝􏷆void􏷅􏷄data􏷃􏷀Data to be copied into buffer􏶿
􏶜􏶝􏷆size_t􏷅􏷄data size􏷃􏷀size of the data to be copied into buffer􏶿
􏵪uDataSize % 2 == 0􏵫􏵨data size should be divisible by 2􏵩
􏵦uBufferIterator != 0􏵧􏵤the buffer iterator will increment so that it can be used to pack the next set of data􏵥
􏶴
    􏶲pack data into the byte array􏶱
    memcpy(&􏵶buffer􏵷[*􏵶buffer iterator􏵷],􏵶data􏵷,􏵶data size􏵷);
    
    􏶲potentially reverse the packed data so that it is in little endian􏶱
    􏵲reverse endian by 2 bytes when on big endian machine􏵳&􏵶buffer􏵷[*􏵶buffer iterator􏵷],􏵶data size􏵷);
    
    􏶲increment our buffer iterator for the next pack􏶱
    *􏵶buffer iterator􏵷+= 􏵶data size􏵷;
􏶳

􏷘+􏷗􏷒unpack little endian 2 byte invariance􏷑
􏷐Unpacks a type stored as little endian from a data buffer􏷏
􏶠the bytes of the type are converted to little endian with a 2 byte invariance􏶡 
􏶜􏶝􏷆BYTE[]􏷅􏷄buffer􏷃􏷀Reference to data buffer􏶿
􏶜mr􏶝􏷆size_t􏷅􏷄buffer iterator􏷃􏷀the index of the buffer to start packing the data at􏶿
􏶜mr􏶝􏷆void􏷅􏷄data􏷃􏷀Data to be copied into buffer􏶿
􏶜􏶝􏷆size_t􏷅􏷄data size􏷃􏷀size of the data to be copied into buffer􏶿
􏵪uDataSize % 2 == 0􏵫􏵨data size should be divisible by 2􏵩
􏵦uBufferIterator != 0􏵧􏵤the buffer iterator will increment so that it can be used to unpack the next set of data􏵥
􏶴
    􏶲unpack data from byte array􏶱
    memcpy(􏵶data􏵷,&􏵶buffer􏵷[*􏵶buffer iterator􏵷],􏵶data size􏵷);
    
    􏶲potentially reverse the unpacked data so that it is back to big endian􏶱
    􏵲reverse endian by 2 bytes when on big endian machine􏵳􏵶data􏵷,􏵶data size􏵷);

    􏶲increment our buffer iterator for the next unpack􏶱
    *􏵶buffer iterator􏵷+= 􏵶data size􏵷;
􏶳








􏷘+􏷗􏷒pack first n array elements􏷑
􏷐Packs only the first number of array elements specified into a data buffer􏷏
􏶠􏶡 
􏶜m􏶝􏷆BYTE[]􏷅􏷄buffer􏷃􏷀Reference to data buffer􏶿
􏶜mr􏶝􏷆size_t􏷅􏷄buffer iterator􏷃􏷀the index of the buffer to start packing the data at􏶿
􏶜􏶝􏷆void[]􏷅􏷄array􏷃􏷀the array to be packed􏶿
􏶜􏶝􏷆size_t􏷅􏷄element size􏷃􏷀size of a data element in the array􏶿
􏶜􏶝􏷆size_t􏷅􏷄number of elements􏷃􏷀the number of elements to pack from the start of the array􏶿
􏶜􏶝􏷆size_t􏷅􏷄array size􏷃􏷀the maximum size of the array􏶿
􏵪uDataSize % 2 == 0􏵫􏵨data size should be divisible by 2􏵩
􏵪uNumberOfElements <= uArraySize􏵫􏵨the number of elements must not exceed the array size􏵩
􏵦uBufferIterator != 0􏵧􏵤the buffer iterator will increment so that it can be used to unpack the next set of data􏵥
􏶴
    size_t uIndex = 0;
    for (; uIndex < 􏵶number of elements􏵷 && uIndex < 􏵶array size􏵷; ++uIndex){
    
        􏶲increment void pointer the number of appropriate bytes based on element size during each iteration􏶱
        􏵲pack big endian 4 byte invariance􏵳􏵶buffer􏵷,􏵶buffer iterator􏵷,(const char *const)􏵶array􏵷 + (uIndex*􏵶element size􏵷),􏵶element size􏵷);
    }
􏶳

􏷘+􏷗􏷒unpack first n array elements􏷑
􏷐Unpacks only the first number of array elements specified into a data buffer􏷏
􏶠􏶡 
􏶜􏶝􏷆BYTE[]􏷅􏷄buffer􏷃􏷀Reference to data buffer􏶿
􏶜mr􏶝􏷆size_t􏷅􏷄buffer iterator􏷃􏷀the index of the buffer to start packing the data at􏶿
􏶜m􏶝􏷆void[]􏷅􏷄array􏷃􏷀the array to be packed􏶿
􏶜􏶝􏷆size_t􏷅􏷄element size􏷃􏷀size of a data element in the array􏶿
􏶜􏶝􏷆size_t􏷅􏷄number of elements􏷃􏷀the number of elements to unpack from the start of the array􏶿
􏶜􏶝􏷆size_t􏷅􏷄array size􏷃􏷀the maximum size of the array􏶿
􏵪uDataSize % 2 == 0􏵫􏵨data size should be divisible by 2􏵩
􏵪uNumberOfElements <= uArraySize􏵫􏵨the number of elements must not exceed the array size􏵩
􏵦uBufferIterator != 0􏵧􏵤the buffer iterator will increment so that it can be used to unpack the next set of data􏵥
􏶴
    size_t uIndex = 0;
    for (; uIndex < 􏵶number of elements􏵷 && uIndex < 􏵶array size􏵷; ++uIndex){
    
        􏶲increment void pointer the number of appropriate bytes based on element size during each iteration􏶱
        􏵲unpack big endian 4 byte invariance􏵳􏵶buffer􏵷,􏵶buffer iterator􏵷,(char*const)􏵶array􏵷 + (uIndex*􏵶element size􏵷),􏵶element size􏵷);
    }
􏶳




􏷘+􏷗􏷒pack 8 bools into a byte􏷑
􏷐Packs eight BOOLs into a single BYTE of a buffer􏷏
􏶠uses bit shifts on each index of the bool array
note: the bits will be in reverse order of the bools passed in
example: {􏵱,􏵱,􏵱,􏵱,􏵱,􏵱,􏵱,􏵰}
becomes: 01111111􏶡
􏶜m􏶝􏷆BYTE[]􏷅􏷄data buffer􏷃􏷀Reference to data buffer􏶿
􏶜􏶝􏷆BOOL[]􏷅􏷄pack bools􏷃􏷀an array of 8 bools to pack into a byte􏶿
􏶚m􏶛􏶾int􏶽􏶼number of bytes􏶻􏶺Number of bytes packed􏶹
􏶴
    *􏵶data buffer􏵷 = (BYTE)(((􏵶pack bools􏵷[7] << 7) & 0xFF) + ((􏵶pack bools􏵷[6] << 6) & 0xFF) + ((􏵶pack bools􏵷[5] << 5) & 0xFF)
                          + ((􏵶pack bools􏵷[4] << 4) & 0xFF) + ((􏵶pack bools􏵷[3] << 3) & 0xFF) + ((􏵶pack bools􏵷[2] << 2) & 0xFF) 
                          + ((􏵶pack bools􏵷[1] << 1) & 0xFF) + (􏵶pack bools􏵷[0] & 0xFF));
    return sizeof(BYTE);
􏶳

