􏶞g􏶟
􏷲Utilities for packing / unpacking on network data buffers􏷱
􏷰Deals with endianness and address invariance. not padding/offsets
Relies on architecture for endianness􏷯
􏷮Pack Utilities􏷭 􏷮Network􏷭 􏷮Utilities􏷭
􏷬Dave Corapi􏷫
􏷬Trevor Hickey􏷫
􏷤􏷣􏷦Defs.h􏷥􏷢USES: BYTE􏷡
􏷤􏷣􏷦stddef.h􏷥􏷢USES: size_t􏷡
􏷤􏷣􏷦stdioLib.h􏷥􏷢USES: BOOL􏷡
􏶔􏶕􏶒FfsCommon.h􏶓􏶖USES: DwordReverseByteOrder􏶗
􏶔􏶕􏶒strLib.h􏶓􏶖USES: memcpy()􏶗

􏷘+􏷗􏷒pack big endian 4 byte invariance􏷑
􏷐Packs a type into a big endian data buffer􏷏
􏶠DWORDs are revered if needed􏶡
􏶜􏶝􏷆BYTE*const􏷅􏷄buffer􏷃􏷀Reference to data buffer􏶿
􏶜􏶝􏷆size_t*const􏷅􏷄buffer iterator􏷃􏷀the index of the buffer to start packing the data at􏶿
􏶜c􏶝􏷆void*const􏷅􏷄data􏷃􏷀Data to be copied into buffer􏶿
􏶜c􏶝􏷆size_t􏷅􏷄data size􏷃􏷀size of the data to be copied into buffer􏶿
􏵪uDataSize % 4 == 0􏵫􏵨data size should be divisible by 4􏵩
􏵦uBufferIterator != 0􏵧􏵤the buffer iterator will increment so that it can be used to pack the next set of data􏵥
􏶴
    􏶲pack data into the byte array􏶱
    memcpy(&􏵶buffer􏵷[*􏵶buffer iterator􏵷],􏵶data􏵷,􏵶data size􏵷);
    
    􏶲increment our buffer iterator for the next pack􏶱
    *􏵶buffer iterator􏵷+= 􏵶data size􏵷;
    
􏶳

􏷘+􏷗􏷒unpack big endian 4 byte invariance􏷑
􏷐Unpacks a type stored as big endian from a data buffer􏷏
􏶠unpacked􏶡
􏶜c􏶝􏷆BYTE*const􏷅􏷄buffer􏷃􏷀Reference to data buffer􏶿
􏶜􏶝􏷆size_t*const􏷅􏷄buffer iterator􏷃􏷀the index of the buffer to start packing the data at􏶿
􏶜􏶝􏷆void*const􏷅􏷄data􏷃􏷀Data to be copied into buffer􏶿
􏶜c􏶝􏷆size_t􏷅􏷄data size􏷃􏷀size of the data to be copied into buffer􏶿
􏵪uDataSize % 4 == 0􏵫􏵨data size should be divisible by 4􏵩
􏵦uBufferIterator != 0􏵧􏵤the buffer iterator will increment so that it can be used to unpack the next set of data􏵥
􏶴
    􏶲unpack data from byte array􏶱
    memcpy(􏵶data􏵷,&􏵶buffer􏵷[*􏵶buffer iterator􏵷],􏵶data size􏵷);
    
    􏶲increment our buffer iterator for the next unpack􏶱
    *􏵶buffer iterator􏵷+= 􏵶data size􏵷;
􏶳

􏷘+􏷗􏷒pack little endian 4 byte invariance􏷑
􏷐Packs a type into a little endian data buffer􏷏
􏶠􏶡
􏶜􏶝􏷆BYTE*const􏷅􏷄buffer􏷃􏷀Reference to data buffer􏶿
􏶜􏶝􏷆size_t*const􏷅􏷄buffer iterator􏷃􏷀the index of the buffer to start packing the data at􏶿
􏶜c􏶝􏷆void*const􏷅􏷄data􏷃􏷀Data to be copied into buffer􏶿
􏶜c􏶝􏷆size_t􏷅􏷄data size􏷃􏷀size of the data to be copied into buffer􏶿
􏵪uDataSize % 4 == 0􏵫􏵨data size should be divisible by 4􏵩
􏵦uBufferIterator != 0􏵧􏵤the buffer iterator will increment so that it can be used to pack the next set of data􏵥
􏶴
    􏶲pack data into the byte array􏶱
    memcpy(&􏵶buffer􏵷[*􏵶buffer iterator􏵷],􏵶data􏵷,􏵶data size􏵷);
    
    􏶲reverse the packed data so that it is in little endian􏶱
    DwordReverseByteOrder(&􏵶buffer􏵷[*􏵶buffer iterator􏵷],􏵶data size􏵷);
    
    􏶲increment our buffer iterator for the next pack􏶱
    *􏵶buffer iterator􏵷+= 􏵶data size􏵷;
􏶳

􏷘+􏷗􏷒unpack little endian 4 byte invariance􏷑
􏷐Unpacks a type stored as little endian from a data buffer􏷏
􏶠􏶡
􏶜c􏶝􏷆BYTE*const􏷅􏷄buffer􏷃􏷀Reference to data buffer􏶿
􏶜􏶝􏷆size_t*const􏷅􏷄buffer iterator􏷃􏷀the index of the buffer to start packing the data at􏶿
􏶜􏶝􏷆void*const􏷅􏷄data􏷃􏷀Data to be copied into buffer􏶿
􏶜c􏶝􏷆size_t􏷅􏷄data size􏷃􏷀size of the data to be copied into buffer􏶿
􏵪uDataSize % 4 == 0􏵫􏵨data size should be divisible by 4􏵩
􏵦uBufferIterator != 0􏵧􏵤the buffer iterator will increment so that it can be used to unpack the next set of data􏵥
􏶴
    􏶲unpack data from byte array􏶱
    memcpy(􏵶data􏵷,&􏵶buffer􏵷[*􏵶buffer iterator􏵷],􏵶data size􏵷);
    
    􏶲reverse the unpacked data so that it is back to big endian􏶱
    DwordReverseByteOrder(􏵶data􏵷,􏵶data size􏵷);

    􏶲increment our buffer iterator for the next unpack􏶱
    *􏵶buffer iterator􏵷+= 􏵶data size􏵷;
􏶳


􏷘+􏷗􏷒pack big endian 2 byte invariance􏷑
􏷐Packs a type into a big endian data buffer􏷏
􏶠􏶡
􏶜􏶝􏷆BYTE*const􏷅􏷄buffer􏷃􏷀Reference to data buffer􏶿
􏶜􏶝􏷆size_t*const􏷅􏷄buffer iterator􏷃􏷀the index of the buffer to start packing the data at􏶿
􏶜c􏶝􏷆void*const􏷅􏷄data􏷃􏷀Data to be copied into buffer􏶿
􏶜c􏶝􏷆size_t􏷅􏷄data size􏷃􏷀size of the data to be copied into buffer􏶿
􏵪uDataSize % 2 == 0􏵫􏵨data size should be divisible by 2􏵩
􏵦uBufferIterator != 0􏵧􏵤the buffer iterator will increment so that it can be used to pack the next set of data􏵥
􏶴
    􏶲pack data into the byte array􏶱
    memcpy(&􏵶buffer􏵷[*􏵶buffer iterator􏵷],􏵶data􏵷,􏵶data size􏵷);
    
    􏶲increment our buffer iterator for the next pack􏶱
    *􏵶buffer iterator􏵷+= 􏵶data size􏵷;
    
􏶳

􏷘+􏷗􏷒unpack big endian 2 byte invariance􏷑
􏷐Unpacks a type stored as big endian from a data buffer􏷏
􏶠􏶡
􏶜c􏶝􏷆BYTE*const􏷅􏷄buffer􏷃􏷀Reference to data buffer􏶿
􏶜􏶝􏷆size_t*const􏷅􏷄buffer iterator􏷃􏷀the index of the buffer to start packing the data at􏶿
􏶜􏶝􏷆void*const􏷅􏷄data􏷃􏷀Data to be copied into buffer􏶿
􏶜c􏶝􏷆size_t􏷅􏷄data size􏷃􏷀size of the data to be copied into buffer􏶿
􏵪uDataSize % 2 == 0􏵫􏵨data size should be divisible by 2􏵩
􏵦uBufferIterator != 0􏵧􏵤the buffer iterator will increment so that it can be used to unpack the next set of data􏵥
􏶴
    􏶲unpack data from byte array􏶱
    memcpy(􏵶data􏵷,&􏵶buffer􏵷[*􏵶buffer iterator􏵷],􏵶data size􏵷);
    
    􏶲increment our buffer iterator for the next unpack􏶱
    *􏵶buffer iterator􏵷+= 􏵶data size􏵷;
􏶳

􏷘+􏷗􏷒pack little endian 2 byte invariance􏷑
􏷐Packs a type into a little endian data buffer􏷏
􏶠􏶡
􏶜􏶝􏷆BYTE*const􏷅􏷄buffer􏷃􏷀Reference to data buffer􏶿
􏶜􏶝􏷆size_t*const􏷅􏷄buffer iterator􏷃􏷀the index of the buffer to start packing the data at􏶿
􏶜c􏶝􏷆void*const􏷅􏷄data􏷃􏷀Data to be copied into buffer􏶿
􏶜c􏶝􏷆size_t􏷅􏷄data size􏷃􏷀size of the data to be copied into buffer􏶿
􏵪uDataSize % 2 == 0􏵫􏵨data size should be divisible by 2􏵩
􏵦uBufferIterator != 0􏵧􏵤the buffer iterator will increment so that it can be used to pack the next set of data􏵥
􏶴
    􏶲pack data into the byte array􏶱
    memcpy(&􏵶buffer􏵷[*􏵶buffer iterator􏵷],􏵶data􏵷,􏵶data size􏵷);
    
    􏶲reverse the packed data so that it is in little endian􏶱
    ReverseByteOrder(&􏵶buffer􏵷[*􏵶buffer iterator􏵷],􏵶data size􏵷);
    
    􏶲increment our buffer iterator for the next pack􏶱
    *􏵶buffer iterator􏵷+= 􏵶data size􏵷;
􏶳

􏷘+􏷗􏷒unpack little endian 2 byte invariance􏷑
􏷐Unpacks a type stored as little endian from a data buffer􏷏
􏶠􏶡 
􏶜c􏶝􏷆BYTE*const􏷅􏷄buffer􏷃􏷀Reference to data buffer􏶿
􏶜􏶝􏷆size_t*const􏷅􏷄buffer iterator􏷃􏷀the index of the buffer to start packing the data at􏶿
􏶜􏶝􏷆void*const􏷅􏷄data􏷃􏷀Data to be copied into buffer􏶿
􏶜c􏶝􏷆size_t􏷅􏷄data size􏷃􏷀size of the data to be copied into buffer􏶿
􏵪uDataSize % 2 == 0􏵫􏵨data size should be divisible by 2􏵩
􏵦uBufferIterator != 0􏵧􏵤the buffer iterator will increment so that it can be used to unpack the next set of data􏵥
􏶴
    􏶲unpack data from byte array􏶱
    memcpy(􏵶data􏵷,&􏵶buffer􏵷[*􏵶buffer iterator􏵷],􏵶data size􏵷);
    
    􏶲reverse the unpacked data so that it is back to big endian􏶱
    ReverseByteOrder(􏵶data􏵷,􏵶data size􏵷);

    􏶲increment our buffer iterator for the next unpack􏶱
    *􏵶buffer iterator􏵷+= 􏵶data size􏵷;
􏶳








􏷘+􏷗􏷒pack first n array elements􏷑
􏷐Packs only the first number of array elements specified into a data buffer􏷏
􏶠􏶡 
􏶜􏶝􏷆BYTE*const􏷅􏷄buffer􏷃􏷀Reference to data buffer􏶿
􏶜􏶝􏷆size_t*const􏷅􏷄buffer iterator􏷃􏷀the index of the buffer to start packing the data at􏶿
􏶜c􏶝􏷆void*const􏷅􏷄array􏷃􏷀the array to be packed􏶿
􏶜c􏶝􏷆size_t􏷅􏷄element size􏷃􏷀size of a data element in the array􏶿
􏶜c􏶝􏷆size_t􏷅􏷄number of elements􏷃􏷀the number of elements to pack from the start of the array􏶿
􏶜c􏶝􏷆size_t􏷅􏷄array size􏷃􏷀the maximum size of the array􏶿
􏵪uDataSize % 2 == 0􏵫􏵨data size should be divisible by 2􏵩
􏵪uNumberOfElements <= uArraySize􏵫􏵨the number of elements must not exceed the array size􏵩
􏵦uBufferIterator != 0􏵧􏵤the buffer iterator will increment so that it can be used to unpack the next set of data􏵥
􏶴
    size_t uIndex = 0;
    for (; uIndex < 􏵶number of elements􏵷 && uIndex < 􏵶array size􏵷; ++uIndex){
    
        􏶲increment void pointer the number of appropriate bytes based on element size during each iteration􏶱
        􏵲pack big endian 4 byte invariance􏵳􏵶buffer􏵷,􏵶buffer iterator􏵷,(char*)􏵶array􏵷 + (uIndex*􏵶element size􏵷),􏵶element size􏵷);
    }
􏶳

􏷘+􏷗􏷒unpack first n array elements􏷑
􏷐Unpacks only the first number of array elements specified into a data buffer􏷏
􏶠􏶡 
􏶜c􏶝􏷆BYTE*const􏷅􏷄buffer􏷃􏷀Reference to data buffer􏶿
􏶜􏶝􏷆size_t*const􏷅􏷄buffer iterator􏷃􏷀the index of the buffer to start packing the data at􏶿
􏶜􏶝􏷆void*􏷅􏷄array􏷃􏷀the array to be packed􏶿
􏶜c􏶝􏷆size_t􏷅􏷄element size􏷃􏷀size of a data element in the array􏶿
􏶜c􏶝􏷆size_t􏷅􏷄number of elements􏷃􏷀the number of elements to unpack from the start of the array􏶿
􏶜c􏶝􏷆size_t􏷅􏷄array size􏷃􏷀the maximum size of the array􏶿
􏵪uDataSize % 2 == 0􏵫􏵨data size should be divisible by 2􏵩
􏵪uNumberOfElements <= uArraySize􏵫􏵨the number of elements must not exceed the array size􏵩
􏵦uBufferIterator != 0􏵧􏵤the buffer iterator will increment so that it can be used to unpack the next set of data􏵥
􏶴
    size_t uIndex = 0;
    for (; uIndex < 􏵶number of elements􏵷 && uIndex < 􏵶array size􏵷; ++uIndex){
    
        􏶲increment void pointer the number of appropriate bytes based on element size during each iteration􏶱
        􏵲unpack big endian 4 byte invariance􏵳􏵶buffer􏵷,􏵶buffer iterator􏵷,(char*)􏵶array􏵷 + (uIndex*􏵶element size􏵷),􏵶element size􏵷);
    }
􏶳




􏷘+􏷗􏷒pack 8 bools into a byte􏷑
􏷐Packs eight BOOLs into a single BYTE of a buffer􏷏
􏶠uses bit shifts on each index of the bool array
note: the bits will be in reverse order of the bools passed in
example: {􏵱,􏵱,􏵱,􏵱,􏵱,􏵱,􏵱,􏵰}
becomes: 01111111􏶡
􏶜􏶝􏷆BYTE*􏷅􏷄data buffer􏷃􏷀Reference to data buffer􏶿
􏶜􏶝􏷆BOOL*􏷅􏷄pack bools􏷃􏷀an array of 8 bools to pack into a byte􏶿
􏶾int􏶽􏶼number of bytes􏶻􏶺Number of bytes packed􏶹
􏶴
    *􏵶data buffer􏵷 = (BYTE)(((􏵶pack bools􏵷[7] << 7) & 0xFF) + ((􏵶pack bools􏵷[6] << 6) & 0xFF) + ((􏵶pack bools􏵷[5] << 5) & 0xFF)
                          + ((􏵶pack bools􏵷[4] << 4) & 0xFF) + ((􏵶pack bools􏵷[3] << 3) & 0xFF) + ((􏵶pack bools􏵷[2] << 2) & 0xFF) 
                          + ((􏵶pack bools􏵷[1] << 1) & 0xFF) + (􏵶pack bools􏵷[0] & 0xFF));
    return sizeof(BYTE);
􏶳

