#!/usr/bin/env bash

#nonmutatable globals
ACTUAL_REPO="/home/malko/Desktop/work-related/fresh"
CODE_ROOT="SimHost/UH72A VME/Src"
TEST_ROOT="SimHost/Tests/Unit_Tests"
PATH_TO_CODE_ROOT="$ACTUAL_REPO""/""$CODE_ROOT""/"
PATH_TO_TEST_ROOT="$ACTUAL_REPO""/""$TEST_ROOT""/"

function Transfer-Global(){
  Print-Whats-Happening "Global" "$1"
  Export-It-Good "$1";
  Copy-It "$1" "$2";
  Style-It "$1" "$2";
  #Document-It "$1";
  Remove-Generated-Code-From-Work-Area "$1";
}

function Transfer-Object-Good(){
   Print-Whats-Happening "Good Object" "$1"
   Export-It-Good "$1";
   Copy-It "$1" "$2";
   Style-It "$1" "$2";
   Test-It "$1" "$3";
   #Document-It "$1";
   Remove-Generated-Code-From-Work-Area "$1";
 }
function Transfer-Object-Bad(){
   Print-Whats-Happening "Bad Object" "$1" 
   Export-It-Bad "$1";
   Copy-It "$1" "$2";
   Style-It "$1" "$2";
   Test-It "$1" "$3";
   #Document-It "$1";
   Remove-Generated-Code-From-Work-Area "$1";
 }



function Print-Whats-Happening(){

    CapsCaseName=`Caps_Case "$2"`
    
    #print the name of the component or utily nicely
    blue_message "$1"" - " $CapsCaseName;
    echo "";
}
function Export-It-Good(){

  #export unilang stuff
  #currently:
  # - f2si export C code (in directory)
  # - unit test wrapper for f2si components (in directory) 
  unilang-compiler --exporter="f2si" --language="c" --style="good" "$1".UniLang;
}
function Export-It-Bad(){

  #export unilang stuff
  #currently:
  # - f2si export C code (in directory)
  # - unit test wrapper for f2si components (in directory) 
  unilang-compiler --exporter="f2si" --language="c" --style="bad" "$1".UniLang;
}


function Copy-It(){
  
  #folder name it was exported to
  f2siName=`Pushed_Caps_Case $1`;
  
  #if it's a single header file
  count=`ls -1 $f2siName/*.c 2>/dev/null | wc -l`;
  if [ $count == 0 ]; then
  
    #Copy headers into the actual code base (don't transfer folder)
    cp -rf $f2siName/*.h "$PATH_TO_CODE_ROOT""$2" 
    
  #if it's multiple files
  else
  
    #Copy the directory into the actual code base
    cp -rf "$f2siName" "$PATH_TO_CODE_ROOT""$2"
    
  fi
  
}
function Style-It(){

  #folder name it was exported to
  f2siName=`Pushed_Caps_Case $1`;
  
  #basically for headers that don't get created in the folder (occurs when they are headers only)
  PossibleHeaderName="$PATH_TO_CODE_ROOT""$2"/"$f2siName".h
  
  #format the code once it's there (fun fact: clang-format will remove the empty newline at the end; which is undesirable, but unavoidable)
  #We just force format where we think the file is going to show up.  It might be a header file on its own,
  #it might actually be in a newly created directory
  clang-format-3.6 -style=file -i "$PATH_TO_CODE_ROOT""$2"/"$f2siName"/*.h > /dev/null 2>&1;
  clang-format-3.6 -style=file -i "$PATH_TO_CODE_ROOT""$2"/"$f2siName"/*.c > /dev/null 2>&1;
  clang-format-3.6 -style=file -i "$PATH_TO_CODE_ROOT""$2"/"$f2siName"/*.hpp > /dev/null 2>&1;
  clang-format-3.6 -style=file -i "$PATH_TO_CODE_ROOT""$2"/"$f2siName"/*.cpp > /dev/null 2>&1;
  clang-format-3.6 -style=file -i "$PossibleHeaderName" > /dev/null 2>&1;
  
  #optionally do this:
  #need to fix the bulk updater to just bail out if the file doesn't exist.  
  #instead of having it create a file like it does now...
  if [ -f "$PossibleHeaderName" ];
  then
    squeeze-whitespace-lines -i "$PossibleHeaderName" > /dev/null 2>&1;
  fi
  
  #remove-top-empty-lines -i "$PATH_TO_CODE_ROOT""$2"/"$f2siName"/*.h > /dev/null 2>&1;
  #remove-top-empty-lines -i "$PATH_TO_CODE_ROOT""$2"/"$f2siName"/*.c > /dev/null 2>&1;
  
  #rtrim-lines -i "$PATH_TO_CODE_ROOT""$2"/"$f2siName"/*.h > /dev/null 2>&1;
  #rtrim-lines -i "$PATH_TO_CODE_ROOT""$2"/"$f2siName"/*.c > /dev/null 2>&1;
  
  #whitespace-lines-to-empty-lines -i "$PATH_TO_CODE_ROOT""$2"/"$f2siName"/*.h > /dev/null 2>&1;
  #whitespace-lines-to-empty-lines -i "$PATH_TO_CODE_ROOT""$2"/"$f2siName"/*.c > /dev/null 2>&1;
  
  squeeze-whitespace-lines -i "$PATH_TO_CODE_ROOT""$2"/"$f2siName"/*.h > /dev/null 2>&1;
  squeeze-whitespace-lines -i "$PATH_TO_CODE_ROOT""$2"/"$f2siName"/*.c > /dev/null 2>&1;
  
  #Add the empty newline back to the files after formatting (removed by clang format)
  if [ -f "$PossibleHeaderName" ];
  then
    set-a-single-blank-line-to-the-end-of-file -i "$PossibleHeaderName" > /dev/null 2>&1;
  fi
  set-a-single-blank-line-to-the-end-of-file -i "$PATH_TO_CODE_ROOT""$2"/"$f2siName"/*.h > /dev/null 2>&1;
  set-a-single-blank-line-to-the-end-of-file -i "$PATH_TO_CODE_ROOT""$2"/"$f2siName"/*.c > /dev/null 2>&1;
  

  
}
function Test-It(){
  
  #folder name it was exported to
  f2siName=`Pushed_Caps_Case $1`;
  
  mkdir -p "$PATH_TO_TEST_ROOT""$2"/"$f2siName"/"Linux/Src";
  cp -rf "$f2siName""Wrapper" "$PATH_TO_TEST_ROOT""$2"/"$f2siName"/"Linux/Src"
  clang-format-3.6 -style=file -i "$PATH_TO_TEST_ROOT""$2"/"$f2siName"/"Linux/Src"/"$f2siName""Wrapper"/*.hpp
  clang-format-3.6 -style=file -i "$PATH_TO_TEST_ROOT""$2"/"$f2siName"/"Linux/Src"/"$f2siName""Wrapper"/*.cpp
}

function Remove-Generated-Code-From-Work-Area(){

  #folder name it was exported to
  f2siName=`Pushed_Caps_Case $1`;
  
  #removes exported folder
  rm -rf "$f2siName";
  
  #removes wrapper if it exists
  rm -rf "$f2siName""Wrapper";
  
  
}


#Case Formatters:
function Pushed_Caps_Case(){
      echo "$1" | tr _ " " | tr [A-Z] [a-z] | sed "s/\( \|^\)\(.\)/\1\u\2/g" | tr -d " "
}

#For printing nicely
function Caps_Case(){
  echo "$1" | tr _ " " | tr [A-Z] [a-z] | sed -r 's/\<./\U&/g';
}

function Clang-Format-Some-Other-Files(){
echo "formatting other files...";
  #clang-format-3.6 -style=file -i "$PATH_TO_CODE_ROOT""Shared/ffs/FfsCommon.h"
  #clang-format-3.6 -style=file -i "$PATH_TO_CODE_ROOT""Shared/ffs/FfsCommon.c"
  #clang-format-3.6 -style=file -i "$PATH_TO_CODE_ROOT""Shared/ffs/FfsTypes.h"
  #clang-format-3.6 -style=file -i "$PATH_TO_CODE_ROOT""SystemManagers/Electrical"/*.h
  #clang-format-3.6 -style=file -i "$PATH_TO_CODE_ROOT""SystemManagers/Electrical"/*.c
  #clang-format-3.6 -style=file -i "$PATH_TO_CODE_ROOT""Connections/UDP/J2Communication"/*.h
  #clang-format-3.6 -style=file -i "$PATH_TO_CODE_ROOT""Connections/UDP/J2Communication"/*.c
}

function Single-Newline-At-The-End-Of-Every-File(){
  recursively-set-a-single-blank-line-to-the-end-of-files --start-path "$PATH_TO_CODE_ROOT" --file-extension h
  recursively-set-a-single-blank-line-to-the-end-of-files --start-path "$PATH_TO_CODE_ROOT" --file-extension hpp
  recursively-set-a-single-blank-line-to-the-end-of-files --start-path "$PATH_TO_CODE_ROOT" --file-extension c
  recursively-set-a-single-blank-line-to-the-end-of-files --start-path "$PATH_TO_CODE_ROOT" --file-extension cpp
}
function Remove-Whitespace-Lines-At-The-Top-Of-Every-File(){
  recursively-remove-first-whitespace-lines-from-front-of-files --start-path "$PATH_TO_CODE_ROOT" --file-extension h
  recursively-remove-first-whitespace-lines-from-front-of-files --start-path "$PATH_TO_CODE_ROOT" --file-extension hpp
  recursively-remove-first-whitespace-lines-from-front-of-files --start-path "$PATH_TO_CODE_ROOT" --file-extension c
  recursively-remove-first-whitespace-lines-from-front-of-files --start-path "$PATH_TO_CODE_ROOT" --file-extension cpp
}
function Check-For-Duplicate-Headers(){
  recursively-detect-redundant-header-files --start-path "$PATH_TO_CODE_ROOT" --file-extension h
  recursively-detect-redundant-header-files --start-path "$PATH_TO_CODE_ROOT" --file-extension hpp
  recursively-detect-redundant-header-files --start-path "$PATH_TO_CODE_ROOT" --file-extension c
  recursively-detect-redundant-header-files --start-path "$PATH_TO_CODE_ROOT" --file-extension cpp 
}
function Cpp-Check-All-Files(){
  find "$PATH_TO_CODE_ROOT" -type f|while read f; do cppchecker "'""$f""'" --search-paths '/home/malko/Desktop/work-related/fresh/SimHost/UH72A VME/Src' '/home/malko/Desktop/work-related/fresh/SimHost/Tests/Test_Dependencies/For_Linux/VxWorks_Wrappers'; done
}
function Splint-Check-All-Files(){
  find "$PATH_TO_CODE_ROOT" -type f|while read f; do splint-checker "'""$f""'" --search-paths '/home/malko/Desktop/work-related/fresh/SimHost/UH72A VME/Src' '/home/malko/Desktop/work-related/fresh/SimHost/Tests/Test_Dependencies/For_Linux/VxWorks_Wrappers'; done
}
function Hungarian-Notation-Check-All-Files(){
  find "$PATH_TO_CODE_ROOT" -type f|while read f; do f2si-hungarian-notation-validator "'""$f""'" --search-paths '/home/malko/Desktop/work-related/fresh/SimHost/UH72A VME/Src' '/home/malko/Desktop/work-related/fresh/SimHost/Tests/Test_Dependencies/For_Linux/VxWorks_Wrappers'; done
}

